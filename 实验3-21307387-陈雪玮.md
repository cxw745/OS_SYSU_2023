# 本科生实验报告

实验课程: 操作系统原理实验

任课教师: 刘宁

实验题目: **从实模式到保护模式**

专业名称: 计算机科学与技术

学生姓名: **陈雪玮**

学生学号: **21307387**

实验地点: 实验中心D501

实验时间: 2023.4.1

## Section 1 实验概述

* 学习到如何从16位的实模式跳转到32位的保护模式，然后在平坦模式下运行32位程序。

* 学习到如何使用I/O端口和硬件交互，为后面保护模式编程打下基础。

* 完成四个实验任务。

## Section 2 预备知识与实验环境

该节总结实验需要用到的基本知识，以及主机型号、代码编译工具、重要三方库的版本号信息等。

* 预备知识：x86汇编语言程序设计、Linux系统命令行工具

* 实验环境：
  
  * 虚拟机版本/处理器型号：Ubuntu18.04、i386
  
  * 代码编辑环境：Linux
  
  * 代码编译工具：makefile、gcc等
  
  * 重要三方库信息：

## Section 2 实验任务

* 实验任务1：完成课后思考题第9题，并简单总结bootloader的作用是什么。

* 实验任务2：在实验任务1的基础上，完成课后思考题第10题。

* 实验任务3：完成课后思考题第11题。

* 实验任务4：在进入保护模式后，按照如下要求，编写并执行一个自己定义的32位汇编程序，要求简单说一说你的实现思路，并提供结果截图。   
  使用两种不同的自定义颜色和一个自定义的起始位置(x,y)，使得bootloader加载后，在显示屏坐标(x,y)处开始输出自己的学号+姓名拼音首字母缩写，要求相邻字符前景色和背景色必须是相互对调的。公告图片中提供了学号为21307233，姓名为宋小宝，自定义位置(12,12)的输出样式，仅供参考。代码实现框架可参考实验2和实验3的MBR程序。<img src="image/2023-04-01-10-01-18-image.png" title="" alt="" width="352">

## Section 3 实验步骤与实验结果

### ------------------------- 实验任务1 -------------------------

* 任务要求：完成课后思考题第9题，并简单总结bootloader的作用是什么。

* 思路分析：
1. 假设BootLoader的大小不大于五个扇区，计算起始和终止的地址。

2. 利用LBA方式读取硬盘mbr后的五个扇区。

3. 新建`bootloader.asm`，实现输出**run bootloader 21307387_cxw**，以此为标志验证进入bootloader成功。
* 实验步骤：

**bootloader的作用：硬盘一个分区的容量有限，mbr的大小只有512B，因此限制了它的具体功能。所以操作系统内核的加载一般是由bootloader加载进内存。在这次实验中主要是通过mbr加载bootloader，再通过bootloader进入保护模式。**![](image/2023-04-02-21-04-31-image.png)

假设bootloader的大小为5个扇区计算bootloader的起始和终止地址。

| name       | start  | length          | end    |
| ---------- | ------ | --------------- | ------ |
| MBR        | 0x7c00 | 0x200(512B)     | 0x7e00 |
| bootloader | 0x7e00 | 0xa00(512B * 5) | 0x8800 |

新建一个文件`bootloader.asm`，编写`mbr.asm`，以LBA方式读取的主要代码如下：

```nasm
asm_read_hard_disk:                           
; 从硬盘读取一个逻辑扇区

; 参数列表
; ax=逻辑扇区号0~15位
; cx=逻辑扇区号16~28位
; ds:bx=读取出的数据放入地址

; 返回值
; bx=bx+512

    mov dx, 0x1f3
    out dx, al    ; LBA地址7~0

    inc dx        ; 0x1f4
    mov al, ah
    out dx, al    ; LBA地址15~8

    mov ax, cx

    inc dx        ; 0x1f5
    out dx, al    ; LBA地址23~16

    inc dx        ; 0x1f6
    mov al, ah
    and al, 0x0f
    or al, 0xe0   ; LBA地址27~24
    out dx, al

    mov dx, 0x1f2
    mov al, 1
    out dx, al   ; 读取1个扇区

    mov dx, 0x1f7    ; 0x1f7
    mov al, 0x20     ;读命令
    out dx,al

    ; 等待处理其他操作
  .waits:
    in al, dx        ; dx = 0x1f7
    and al,0x88
    cmp al,0x08
    jnz .waits                         


    ; 读取512字节到地址ds:bx
    mov cx, 256   ; 每次读取一个字，2个字节，因此读取256次即可          
    mov dx, 0x1f0
  .readw:
    in ax, dx
    mov [bx], ax
    add bx, 2
    loop .readw

    ret
```

`bootloader.asm`代码如下

```nasm
org 0x7e00
[bits 16]
mov ax, 0xb800 ;显存的初始位置
mov gs, ax
mov ah, 0x03 ;青色
mov ecx, bootloader_tag_end-bootloader_tag
xor ebx, ebx
mov esi, bootloader_tag ;是循环的次数也是字符串的下标
output_bootloader_tag:
    mov al, [esi] ;要显示的字符
    mov word[gs:bx], ax ;gs存着当前访问的显存地址，将ax写入显存，显示字符
    inc esi    ;esi是循环的次数
    add ebx, 2 ;每个字符两个字节，高地址是颜色，低地址是内容
    loop output_bootloader_tag  ;loop的作用是让程序块重复执行，执行的次数以ECX的值为依据，
                ;若ECX不等于0则继续跳转到指定标号重新执行，若等于0则不跳转。
jmp $ ;无限循环

bootloader_tag db 'run bootloader 21307387_cxw' ;要显示的内容
bootloader_tag_end: ;这个标识符表示程序结束的地址
```

编译`mbr.asm`写入硬盘起始编号为0的扇区。

```context
nasm -f bin mbr.asm -o mbr.bin
dd if=mbr.bin of=hd.img bs=512 count=1 seek=0 conv=notrunc
```

编译`bootloader.asm`，写入硬盘起始编号为1的扇区，共有5个扇区。

```context
nasm -f bin bootloader.asm -o bootloader.bin
dd if=bootloader.bin of=hd.img bs=512 count=5 seek=1 conv=notrunc
```

使用qemu运行，即可得到结果。

* 实验结果展示：通过执行前述代码，可得下图结果。

![](image/2023-03-29-20-43-47-image.png)

![](image/2023-03-29-20-50-58-image.png)

### ------------------------- 实验任务2 -------------------------

* 任务要求：在实验任务1的基础上，完成课后思考题第10题。

* 思路分析：
1. 计算得到bootloader的CHS参数，bootloader应该从**0柱面0磁头2扇区**开始访问，共访问5个扇区。

2. 利用中断**直接磁盘服务(Direct Disk Service—— `INT 13H`)** 的功能读取磁盘。

3. 修改实验任务1中的`mbr.asm`代码中的函数`asm_read_hard_disk`为CHS方式加载bootlaoder。
* 实验步骤：

计算CHS：`LBA 和 CHS 转换： LBA = (cylinder * HPC + head) * SPT + sector - 1`

对应**直接磁盘服务(Direct Disk Service——INT 13H)** 的参数![](image/2023-03-29-21-04-19-image.png)

修改代码如下：

```nasm
asm_read_hard_disk_chs:                           
;用中断号0x13实现CHS模式读取磁盘加载bootloader
    mov ah, 02h
    mov al, 5
    mov ch, 0
    mov cl, 2
    mov dh, 0
    mov dl, 80h
    int 0x13
    ret
```

* 实验结果展示：通过执行前述代码，可得下图结果。

![](image/2023-03-29-21-03-32-image.png)

### ------------------------- 实验任务3 -------------------------

* 任务要求：完成课后思考题第11题。

* 思路分析：
1. 准备GDT，用lgdt指令加载GDTR信息。

2. 打开第21根地址线。

3. 开启cr0的保护模式标志位。

4. 远跳转，进入保护模式。
* 实验步骤：

首先对内存地址规划：

| Name       | Start  | Length          | End    |
| ---------- | ------ | --------------- | ------ |
| MBR        | 0x7c00 | 0x200(512B)     | 0x7e00 |
| bootloader | 0x7e00 | 0xa00(512B * 5) | 0x8800 |
| GDT        | 0x8800 | 0x80(8B * 16)   | 0x8880 |

将所有常量都放在`boot.inc`中

```nasm
; 常量定义区
; _____________Loader_____________
; 加载器扇区数
LOADER_SECTOR_COUNT equ 5
; 加载器起始扇区
LOADER_START_SECTOR equ 1
; 加载器被加载地址
LOADER_START_ADDRESS equ 0x7e00
; _____________GDT_____________
; GDT起始位置
GDT_START_ADDRESS equ 0x8800
; _____________Selector_____________
;平坦模式数据段选择子
DATA_SELECTOR equ 0x8
;平坦模式栈段选择子
STACK_SELECTOR equ 0x10
;平坦模式视频段选择子
VIDEO_SELECTOR equ 0x18
VIDEO_NUM equ 0x18
;平坦模式代码段选择子
CODE_SELECTOR equ 0x20
```

创建`bootloader.asm`，在其中分别实现进入保护模式的四个步骤：

1. **准备GDT，用lgdt指令加载GDTR信息**。
2. **打开第21根地址线**。
3. **开启cr0的保护模式标志位**。
4. **远跳转，进入保护模式**。

我们等等要在关键步骤debug，因此加上第五步：

5. **在四个关键步骤前设置标识符BREAK1、BREAK2、BREAK3、BREAK4。**

代码如下：

```nasm
;1.准备GDT，用lgdt指令加载GDTR信息。
BREAK1:
;空描述符
mov dword [GDT_START_ADDRESS+0x00],0x00
mov dword [GDT_START_ADDRESS+0x04],0x00  

;创建描述符，这是一个数据段，对应0~4GB的线性地址空间
mov dword [GDT_START_ADDRESS+0x08],0x0000ffff    ; 基地址为0，段界限为0xFFFFF
mov dword [GDT_START_ADDRESS+0x0c],0x00cf9200    ; 粒度为4KB，存储器段描述符 

;建立保护模式下的堆栈段描述符      
mov dword [GDT_START_ADDRESS+0x10],0x00000000    ; 基地址为0x00000000，界限0x0 
mov dword [GDT_START_ADDRESS+0x14],0x00409600    ; 粒度为1个字节

;建立保护模式下的显存描述符   
mov dword [GDT_START_ADDRESS+0x18],0x80007fff    ; 基地址为0x000B8000，界限0x07FFF 
mov dword [GDT_START_ADDRESS+0x1c],0x0040920b    ; 粒度为字节

;创建保护模式下平坦模式代码段描述符
mov dword [GDT_START_ADDRESS+0x20],0x0000ffff    ; 基地址为0，段界限为0xFFFFF
mov dword [GDT_START_ADDRESS+0x24],0x00cf9800    ; 粒度为4kb，代码段描述符 

;初始化描述符表寄存器GDTR
mov word [pgdt], 39      ;描述符表的界限   
lgdt [pgdt]

;2.打开第21根地址线。
BREAK2:
in al,0x92                         ;南桥芯片内的端口 
or al,0000_0010B
out 0x92,al                        ;打开A20

;3.开启cr0的保护模式标志位。
BREAK3:
cli                                ;中断机制尚未工作
mov eax,cr0
or eax,1
mov cr0,eax                        ;设置PE位

;4.远跳转，进入保护模式。
BREAK4:
;以下进入保护模式
jmp dword CODE_SELECTOR:protect_mode_begin
```

使用makefile进入gdb调试

![](image/2023-03-31-21-23-13-image.png)

在bootloader起始地址设置断点并执行、打开窗口并添加符号表

![](image/2023-03-31-21-34-01-image.png)![](image/2023-03-31-21-35-41-image.png)

在四个关键步骤的标识处设置断点，并结合代码、寄存器的内容等来分析这4个步骤

![](image/2023-03-31-21-39-30-image.png)

**1.准备GDT，用lgdt指令加载GDTR信息**。

查看GDT的5个段描述符的内容，与我们预期的相符。

使用的指令为`x/5xg 0x8800`，解释如下![](image/2023-03-31-21-57-46-image.png)

结果如下图

![](image/2023-03-31-21-56-57-image.png)

**2.打开第21根地址线**。

![](image/2023-03-31-22-01-51-image.png)

**3.开启cr0的保护模式标志位**。

用cli取消中断机制，开启cr0的保护模式标志位，当PE=1时为保护模式。

**4.远跳转，进入保护模式**。

地址转变如下，跳转成功，进入保护模式

![](image/2023-03-31-22-06-03-image.png)![](image/2023-03-31-22-07-37-image.png)

* 实验结果展示：通过执行前述代码，可得下图结果。![](image/2023-03-31-15-09-38-image.png)

### ------------------------- 实验任务4 -------------------------

* 任务要求：在进入保护模式后，按照如下要求，编写并执行一个自己定义的32位汇编程序，要求简单说一说你的实现思路，并提供结果截图。   
  使用两种不同的自定义颜色和一个自定义的起始位置(x,y)，使得bootloader加载后，在显示屏坐标(x,y)处开始输出自己的学号+姓名拼音首字母缩写，要求相邻字符前景色和背景色必须是相互对调的。公告图片中提供了学号为21307233，姓名为宋小宝，自定义位置(12,12)的输出样式，仅供参考。代码实现框架可参考实验2和实验3的MBR程序。<img src="image/2023-04-01-09-55-49-image.png" title="" alt="" width="423">

* 思路分析：
1. 我的程序将在(10,3)处开始显示字符，因此计算得到显示字符的起始地址为`VIDEO_SELECTOR + (10*80+3)*2`。选择的两种颜色是青色和红色。

2. 修改进入保护模式后显示字符的代码部分，将显示的字符修改为`21307387_cxw`。

3. 在每次进入循环时修改将前景色和背景色互换。
* 实验步骤：

修改显示字符的初始偏移地址，结果存在ebx寄存器中。

```nasm
mov ebx, (10*80+3)*2
```

设置ah初始值，进入显示字符的循环中，并且显示完一个字符后调用`change`函数调换前景色和背景色。

```nasm
mov ah, 0100_0011b
output_info:
    mov al, [esi]
    mov word[gs:ebx], ax
    add ebx, 2
    inc esi
    call change
    loop output_info
jmp $ ; 死循环
```

change函数实现：

```nasm
change:
    jmp comp
    change1:
        mov ah,0011_0100b
        ret
    change2:
    mov ah,0100_0011b
        ret
    comp:
    cmp ah,0100_0011b
        je change1
        jmp change2
```

* 实验结果展示：用`make build`和`make run`运行修改后的代码，结果如下。![](image/2023-04-01-13-05-34-image.png)

## Section 4 实验总结与心得体会

学习了如何从实模式跳转到保护模式，并在平坦模式下运行32位程序。除此之外，也学习到如何使用I/O端口与硬件交互。在学习实验内容和完成实验任务过程中，学到了LBA、CHS两种弄读取磁盘的方式，学习了gdb+qemu源码级的debug方式，最终完成了四个实验任务。

完成实验任务后，我加深了对计算机硬件的理解，对操作系统的认识，也锻炼了我拆解问题、解决困难的能力。

## Section 5 对实验的改进建议和意见

无

## Section 6 附录：参考资料清单

[INT13中断详解_aweth0me的博客-CSDN博客](https://blog.csdn.net/brainkick/article/details/7583727)

[gdb查看内存地址和栈中的值—查看虚函数表、函数地址_vscode gdb 查看一个地址附近的值_ztguang的博客-CSDN博客](https://blog.csdn.net/ztguang/article/details/51015760#:~:text=gdb%E6%9F%A5%E7%9C%8B%E6%8C%87%E5%AE%9A%E5%9C%B0%E5%9D%80%E7%9A%84%E5%86%85%E5%AD%98%E5%9C%B0%E5%9D%80%E7%9A%84%E5%80%BC%EF%BC%9Aexamine%20%E7%AE%80%E5%86%99%20x-----%E4%BD%BF%E7%94%A8gdb%3E%20help%20x%20%E6%9D%A5%E6%9F%A5%E7%9C%8B%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F%20x%2F,%28n%2Cf%2Cu%E4%B8%BA%E5%8F%AF%E9%80%89%E5%8F%82%E6%95%B0%29%20n%3A%20%E9%9C%80%E8%A6%81%E6%98%BE%E7%A4%BA%E7%9A%84%E5%86%85%E5%AD%98%E5%8D%95%E5%85%83%E4%B8%AA%E6%95%B0%EF%BC%8C%E4%B9%9F%E5%B0%B1%E6%98%AF%E4%BB%8E%E5%BD%93%E5%89%8D%E5%9C%B0%E5%9D%80%E5%90%91%E5%90%8E%E6%98%BE%E7%A4%BA%E5%87%A0%E4%B8%AA%E5%86%85%E5%AD%98%E5%8D%95%E5%85%83%E7%9A%84%E5%86%85%E5%AE%B9%EF%BC%8C%E4%B8%80%E4%B8%AA%E5%86%85%E5%AD%98%E5%8D%95%E5%85%83%E7%9A%84%E5%A4%A7%E5%B0%8F%E7%94%B1%E5%90%8E%E9%9D%A2%E7%9A%84u%E5%AE%9A%E4%B9%89%20f%EF%BC%9A%E6%98%BE%E7%A4%BA%E6%A0%BC%E5%BC%8F%20x%20%28hex%29%20%E6%8C%89%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6%E6%A0%BC%E5%BC%8F%E6%98%BE%E7%A4%BA%E5%8F%98%E9%87%8F%E3%80%82)

## Section 7 附录：代码清单

**任务x的代码放在相应数字的文件夹内，如任务1的代码放在名字为1的文件夹内**
