# 本科生实验报告

实验课程: 操作系统原理实验

任课教师: 刘宁

实验题目: **从实模式到保护模式**

专业名称: 计算机科学与技术

学生姓名: **陈雪玮**

学生学号: **21307387**

实验地点: 实验中心D501

实验时间: 2023.5.14

## Section 1 实验概述

* 使用硬件支持的源自指令实现自旋锁SpinLock。

* 使用SpinLock实现信号量。

* 使用SpinLock和信号量实现两个线程互斥的解决方案。

## Section 2 预备知识与实验环境

该节总结实验需要用到的基本知识，以及主机型号、代码编译工具、重要三方库的版本号信息等。

- 预备知识：x86汇编语言程序设计、Linux系统命令行工具

- 实验环境：
  
  - 虚拟机版本/处理器型号：Ubuntu18.04、i386
  
  - 代码编辑环境：Linux
  
  - 代码编译工具：makefile、gcc等
  
  - 重要三方库信息：

## Section 2 实验任务

- 实验任务1：⾃旋锁与信号量的实现
  
  - ⼦任务1—利⽤⾃旋锁和信号量实现同步
  
  - ⼦任务2—⾃实现锁机制

- 实验任务2：⽣产者-消费者问题
  
  - ⼦任务1—线程的竞争与冲突
  
  - ⼦任务2—利⽤信号量解决问题

- 实验任务3：哲学家就餐问题
  
  - ⼦任务1—简单解决⽅法
  
  - ⼦任务2—死锁应对策略

## Section 3 实验步骤与实验结果

### ------------------------- 实验任务1 -------------------------

- 任务要求：⾃旋锁与信号量的实现
  
  - ⼦任务1—利⽤⾃旋锁和信号量实现同步
  
  > 在实验6中，我们实现了⾃旋锁和信号量机制。现在，请同学们分别利⽤指导书中实现的⾃旋锁和信号量⽅法，解决实验6指导书中的“消失的芝⼠汉堡”问题，保存结果截图并说说你的总体思路。**注意:请将你姓名的英⽂缩写包含在某个线程的输出信息中（⽐如，代替⺟亲或者⼉⼦），⽤作结果截图中的个⼈信息表征。**
  
  - ⼦任务2—⾃实现锁机制
  
  > 实验6教程中使⽤了原⼦指令 xchg 来实现⾃旋锁。但这种⽅法并不是唯⼀的。例如，x86指令中提供了另外⼀个原⼦指令 bts 和 lock 前缀等，这些指令也可以⽤来实现锁机制。现在，同学们需要结合⾃⼰所学的知识，实现⼀个与指导书实现⽅式不同的锁机制。最后，尝试⽤你实现的锁机制解决“消失的芝⼠汉堡”问题，保存结果截图并说说你的总体思路。           

- 思路分析：
  
  - ⼦任务1—利⽤⾃旋锁和信号量实现同步
    
    - 自旋锁
      
      定义一个共享变量bolt，bolt初始化为0。在线程进入临界区前，需要检查bolt是否为0。bolt为0表示未加锁，允许线程进入临界区；bolt为1表示已假锁，禁止线程进入临界区。线程进入临界区前检查bolt的值，若为0，进入临界区，并设置bolt为1，离开临界区设置bolt为0；若为1，循环检查bolt的值，直到bolt为0，进入临界区。
      
      因此解决方法是实现自旋锁，在母亲制作芝士汉堡的线程执行时上锁，在晾完衣服并检查芝士汉堡后，才释放锁。
    
    - 信号量
      
      定义一个共享变量counter，P操作和V操作。counter表示临界区资源数量，是非负整数；P操作在线程进入临界区前执行，检查counter，若大于0，则counter减一，让线程进入临界区，若等于0，则阻塞线程，接着将其挂载到信号量的阻塞队列中；V操作在线程离开临界区后执行，counter加一，检查信号量的阻塞队列是否有线程，如果有，将其唤醒。当线程申请进入临界区时，线程执行P操作；离开临界区时，执行V操作。要注意的是，counter和阻塞队列是共享变量，需要实现互斥访问，这里使用自旋锁实现。
      
      因此解决方法是实现信号量，临界区资源数量设置为1，在母亲制作芝士汉堡的线程执行时执行P操作，在晾完衣服并检查芝士汉堡后，执行V操作。
  
  - ⼦任务2—⾃实现锁机制
    
    - lock：x86指令集允许指令中有一个操作数是内存地址。x86硬件提供了一个机制，在一条指令前添加`lock`前缀，这条指令在内存的读和写都会原子地完成。x86的CPU和高速缓存之间是通过总线连接的，因此在80486时代，实现`lock`指令前缀的方法很简单，就是把总线锁住，它是一个真正的总线锁，因此叫`lock`。实现源自交换函数时，对每一条指令使用`lock`前缀，即可实现原子交换操作。

- 实验步骤：
  
  - ⼦任务1—利⽤⾃旋锁和信号量实现同步
    
    - 原子交换函数
      
      ```nasm
      ; void asm_atomic_exchange(uint32 *register, uint32 *memeory)
      asm_atomic_exchange:
          push ebp
          mov ebp, esp
          pushad
      
          mov ebx, [ebp + 4 * 2] ; register指针存入ebx
          mov eax, [ebx]         ; register值存入eax
          mov ebx, [ebp + 4 * 3] ; memory指针存入ebx
          xchg [ebx], eax        ; memory指针指向的地址存的值变为register值 eax存有memory值
          mov ebx, [ebp + 4 * 2] ; register指针存入ebx
          mov [ebx], eax         ; register指针指向的地址存的值变为memory值
      
          popad
          pop ebp
          ret
      ```
    
    - 自旋锁
      
      上锁
      
      ```c
      void SpinLock::lock()
      {
          uint32 key = 1; //想要获得锁
      
          do
          {
              asm_atomic_exchange(&key, &bolt); //这是“原子”操作
              //printf("pid: %d\n", programManager.running->pid);
          } while (key);
      }
      ```
      
      释放锁
      
      ```c
      void SpinLock::unlock()
      {
          bolt = 0;
      }
      ```
    
    - 信号量
      
      P操作
      
      ```c
      void Semaphore::P()
      {
          PCB *cur = nullptr;
      
          while (true)
          {
              semLock.lock();
              if (counter > 0)
              {
                  --counter;
                  semLock.unlock();
                  return;    
              }
              else
              {
                  cur = programManager.running;
                  waiting.push_back(&(cur->tagInGeneralList));
                  cur->status = ProgramStatus::BLOCKED;
                  //释放锁 并继续调度线程
                  semLock.unlock();
                  programManager.schedule();
              }
          }
      }
      ```
      
      V操作
      
      ```c
      void Semaphore::V()
      {
          semLock.lock();
          ++counter;
          // 阻塞队列中如果有线程，就唤醒
          if (waiting.size())
          {
              PCB *program = ListItem2PCB(waiting.front(), tagInGeneralList);
              waiting.pop_front();
              semLock.unlock();
              programManager.MESA_WakeUp(program);
          }
          else
          {
              semLock.unlock();
          }
      }
      ```
  
  - ⼦任务2—⾃实现锁机制
    
    使用`lock`前缀实现原子交换函数，代码如下。
    
    ```nasm
    ; void asm_atomic_exchange(uint32 *register, uint32 *memeory);
    asm_atomic_exchange:
        push ebp
        mov ebp, esp
        pushad
        ;-----------------------------------------lock
        lock mov eax, [ebp + 4 * 2] 
        lock mov ebx, [ebp + 4 * 3]
        lock mov ecx, [eax]
        lock mov edx, [ebx]
        lock mov [eax], edx
        lock mov [ebx], ecx
        popad
        pop ebp
        ret
    ```

- 实验结果展示：通过执行前述代码，可得下图结果。
  
  ![](image/2023-05-10-20-00-53-image.png)

### ------------------------- 实验任务2 -------------------------

- 任务要求：⽣产者-消费者问题
  
  - 总要求与问题场景
  
  > 1. 同学们请在下述问题场景A或问题场景B中选择⼀个，然后在实验6教程的代码环境下创建多个线程来模拟你选择的问题场景。同学们需⾃⾏决定每个线程的执⾏次数，以⽅便观察临界资源变化为⾸要原则。  
  > 
  > 2. 请将你学号的后4位包含在其中⼀个线程的输出信息中，⽤作结果截图中的个⼈信息表征。例如，学号为 21319527 的同学选择问题A，并扮演服务⽣A，则服务⽣A放⼊1块蛋糕时，程序输出 "`Waiter-A 9527 put a piece of matcha cake in the plate.`"
  > -  问题场景A：宴会蛋糕服务  
  >   
  >   - 问题描述：某位商⼈在餐厅举⾏⽣⽇宴会。餐桌上有⼀个点⼼盘，最多可容纳5块蛋糕，**每个⼈（服务⽣或者来宾）每次只能放⼊/拿出1块蛋糕**。服务⽣A负责向点⼼盘中放⼊抹茶蛋糕，服务⽣B负责向点⼼盘中放⼊芒果蛋糕。⽣⽇宴会上⼀共有6位男性来宾和4位⼥性来宾，男性来宾等待享⽤抹茶蛋糕，⼥性来宾则等待享⽤芒果蛋糕。**如果盘中没有对应⼝味的蛋糕且点⼼盘没有放满**，来宾会给相应的服务⽣发送⼀个请求服务信号，服务⽣收到信号后会放⼊1块蛋糕。
  > 
  > - 问题场景B：抽烟者与供应商
  >   
  >   - 问题描述：酒馆的吧台坐着3位抽烟者和1位供应商。每位抽烟者会不停地卷烟并抽掉，但是要卷起并抽掉⼀⽀烟，抽烟者需要三种材料：烟草、纸和胶⽔。三位抽烟者中，第1位拥有烟草，第2位拥有纸，第3位拥有胶⽔。供应商会源源不断地提供三种材料，每次他会将两种随机的材料组合放在吧台的桌⾯上，拥有剩下那种材料的抽烟者，会⽴刻取⾛材料卷⼀根烟并抽掉它，然后给供应商发送⼀个完成信号，供应商就会放另外两种不同的材料组合在桌⾯上，这样的过程⼀直重复。

- 思路分析：
  
  生产者-消费者问题描述：
  
  > - 生产者生成数据放入缓冲区。
  > 
  > - 消费者从缓冲区取走数据。
  > 
  > - 任何时刻，只能由一个生产者或消费者可以访问缓冲区。
  
  - 问题场景A：宴会蛋糕服务
    
    生产者是服务员A和服务员B，消费者是男性来宾和女性来宾，资源是抹茶蛋糕和芒果蛋糕，解决策略是只有当消费者需要的资源空时，才请求生产者在共享数据区放入资源，当没有请求时，生产者等待；当没有资源时，消费者发出请求，生产者放入资源。
    
    因此，需要同步资源数和实现互斥。使用四个信号量实现，如下。
    
    ```cpp
    // ------------------------定义信号量和变量
    Semaphore mutex;// 互斥锁
    Semaphore matcha_source;// 抹茶蛋糕资源数
    Semaphore mango_source;// 芒果蛋糕资源数
    Semaphore cake_space;// 空间资源数
    ```
    
    实现需要资源再请求生产者提供使用变量实现。在进入临界区前，生产者请求空间资源，消费者请求数据资源；离开临界区时，释放相应的资源。得到资源后，再用互斥锁实现互斥。
  
  - 问题场景B：抽烟者与供应商
    
    生产者是供应商，消费者是三个抽烟者，资源是烟草、纸巾、胶水，解决策略是一位消费者对应一类资源，当这位消费者消费完资源后，发出请求，生产者生产对应的资源，当没有资源时，消费者等待。
    
    供应者与三个抽烟者是同步关系，供应者只能满足一个抽烟者，所以三个抽烟者是互斥关系。

- 实验步骤：
  
  - 问题场景A：宴会蛋糕服务
    
    ```cpp
    // ------------------------定义信号量和变量
    Semaphore mutex;// 互斥锁
    Semaphore matcha_source;// 抹茶蛋糕资源数
    Semaphore mango_source;// 芒果蛋糕资源数
    Semaphore cake_space;// 空间数
    const int N = 5;
    int space = N;// 盘子还能装几块蛋糕
    int matcha = 0;// 盘子里有几块抹茶蛋糕
    int mango = 0;// 盘子里有几块芒果蛋糕
    int delay;
    //--------------------------定义函数
    void a_waiterA_make_match(void *arg)
    {   
        while(1)
        {
            //抹茶蛋糕没有了才会放入
            if(matcha)
            {
                while(1)
                {
                    if(!matcha){break;}
                }
            }
    
            cake_space.P();
            mutex.P();
            printf("Now %d matcha cakes,%d mango cakes,%d space.\n",matcha, mango, space);
    
            delay = 0x1fffffff;
            while (--delay){}
    
            printf("+ Waiter-A 2130 put a piece of matcha cake in the plate.\n");
            ++matcha;
            --space;
            matcha_source.V();
            mutex.V();
        }   
    }
    void a_waiterB_make_mango(void *arg)
    {   
        while(1)
        {
            if(mango)
            {
                while(1)
                {
                    if(!mango){break;}
                }
            }
            cake_space.P();
            mutex.P();
            printf("Now %d matcha cakes,%d mango cakes,%d space.\n",matcha, mango, space);
    
            delay = 0x1fffffff;
            while (--delay){}
    
            printf("+ Waiter-B 7387 put a piece of mango cake in the plate.\n");
            ++mango;
            --space;
            mango_source.V();
            mutex.V();
        }   
    }
    template<int T>
    void a_man_eat_matcha(void *arg)
    {
        while(1)
        {
            if(!matcha)
            {
                printf("Now %d matcha cakes,%d mango cakes,%d space.\n",matcha, mango, space);
                printf("- man %d call waiterA.\n", T);
                while(1)
                {
                    if(matcha)
                    {
                        break;
                    }
                }
            }
            matcha_source.P();
            mutex.P();
            printf("Now %d matcha cakes,%d mango cakes,%d space.\n",matcha, mango, space);
    
            delay = 0x1fffffff;
            while (--delay){}
    
            printf("- man %d eat a matcha cake.\n", T);
            --matcha;
            ++space;
    
            cake_space.V();
            mutex.V();
        }
    }
    
    template<int T>
    void a_woman_eat_mango(void *arg)
    {
        while(1)
        {
            if(!matcha)
            {
                printf("Now %d matcha cakes,%d mango cakes,%d space.\n",matcha, mango, space);
                printf("- woman %d call waiterB.\n", T);
                while(1)
                {
                    if(mango)
                    {
                        break;
                    }
                }
            }
            mango_source.P();
            mutex.P();
            printf("Now %d matcha cakes,%d mango cakes,%d space.\n",matcha, mango, space);
    
            delay = 0x1fffffff;
            while (--delay){}
    
            printf("- woman %d eat a mango cake.\n", T);
            --mango;
            ++space;
    
            cake_space.V();
            mutex.V();
        }
    }
    
    
    
    void first_thread(void *arg)
    {
        // 第1个线程不可以返回
        stdio.moveCursor(0);
        for (int i = 0; i < 25 * 80; ++i)
        {
            stdio.print(' ');
        }
        stdio.moveCursor(0);
    
        mutex.initialize(1);
        cake_space.initialize(5);
        mango_source.initialize(0);
        matcha_source.initialize(0);
        //--------------------------------创建六个男人四个女人的线程
        programManager.executeThread(a_waiterA_make_match, nullptr, "waiterA1", 1);
        programManager.executeThread(a_waiterB_make_mango, nullptr, "waiterB1", 1);
        programManager.executeThread(a_man_eat_matcha<1>, nullptr, "man1", 1);
        programManager.executeThread(a_man_eat_matcha<2>, nullptr, "man2", 1);
        programManager.executeThread(a_man_eat_matcha<3>, nullptr, "man3", 1);
        programManager.executeThread(a_man_eat_matcha<4>, nullptr, "man4", 1);
        programManager.executeThread(a_man_eat_matcha<5>, nullptr, "man5", 1);
        programManager.executeThread(a_man_eat_matcha<6>, nullptr, "man6", 1);
        programManager.executeThread(a_woman_eat_mango<1>, nullptr, "woman1", 1);
        programManager.executeThread(a_woman_eat_mango<2>, nullptr, "woman2", 1);
        programManager.executeThread(a_woman_eat_mango<3>, nullptr, "woman3", 1);
        programManager.executeThread(a_woman_eat_mango<4>, nullptr, "woman4", 1);
    
    
        asm_halt();
    }
    ```
  
  - 问题场景B：抽烟者与供应商
    
    ```cpp
    // ------------------------定义信号量和变量
    Semaphore tobacco;// 拥有烟草者需要的材料
    Semaphore paper; // 纸
    Semaphore glue; // 胶水
    Semaphore finish;// 允许几个人抽烟
    int t=0,p=0,g=0;
    int delay;
    //--------------------------定义函数
    void smoker_with_tobacco(void *arg)
    {   
        while(1)
        {
            tobacco.P();
            finish.P();
            //-----------smoke
            printf("%d tobacco %d paper %d glue.",t, p, g);
            printf("- smoker with tobacco is smoking.\n");
            --p;
            --g;
            delay = 0x1112ffff;
            while(--delay){}
    
            delay = 0x1111ffff;
            while(--delay){}
        }   
    }
    
    void smoker_with_paper(void *arg)
    {
        while(1)
        {   
            paper.P();
            finish.P();
    
            //-----------smoke
            printf("%d tobacco %d paper %d glue.",t, p, g);
            printf("- smoker with paper is smoking.\n");
            --t;
            --g;
            delay = 0x1111ffff;
            while(--delay){}
    
            delay = 0x1111ffff;
            while(--delay){}
        }   
    }
    
    void smoker_with_glue(void *arg)
    {
        while(1)
        {
    
            glue.P();
            finish.P();
    
            //-----------smoke
            printf("%d tobacco %d paper %d glue.",t, p, g);
            printf("- smoker with glue is smoking.\n");
            --t;
            --p;
            delay = 0x1111ffff;
            while(--delay){}
    
            delay = 0x1111ffff;
            while(--delay){}
        }   
    }
    
    void provider_with_two(void *arg)
    {
        int r = 0;
        while(1)
        {
            r = (r+7)%3;
    
            printf("%d tobacco %d paper %d glue.",t, p, g);
            //--------------等待三种请求的其中一种
            if(r == 0)
            {
                printf("+ provider7387 gives paper and glue.\n");
                delay = 0x1111ffff;
                while(--delay){}
                tobacco.V();
                ++p;
                ++g;
            }
            else if (r == 1)
            {
                printf("+ provider gives tobacco and glue.\n");
                delay = 0x1111ffff;
                while(--delay){}
                paper.V();
                ++t;
                ++g;
            }
            else if(r == 2)
            {
                printf("+ provider gives tobacco and paper.\n");
                delay = 0x1111ffff;
                while(--delay){}
                glue.V();
                ++t;
                ++p;
            }
    
            finish.V();
            delay = 0x1111ffff;
            while(--delay){}
        }
    }
    
    
    void first_thread(void *arg)
    {
        // 第1个线程不可以返回
        stdio.moveCursor(0);
        for (int i = 0; i < 25 * 80; ++i)
        {
            stdio.print(' ');
        }
        stdio.moveCursor(0);
    
        mutex.initialize(1);
        tobacco.initialize(0);
        paper.initialize(0);
        glue.initialize(0);
        finish.initialize(1);
        //--------------------------------创建抽烟哥和供应商
        programManager.executeThread(provider_with_two, nullptr, "provider", 1);
        programManager.executeThread(smoker_with_glue, nullptr, "smoker1", 1);
        programManager.executeThread(smoker_with_tobacco, nullptr, "smoker2", 1);
        programManager.executeThread(smoker_with_paper, nullptr, "smoker3", 1);
    
        asm_halt();
    }
    ```
* 实验结果展示：通过执行前述代码，可得下图结果。
  
  - 问题场景A：宴会蛋糕服务
  
  - ![](image/2023-05-15-22-19-17-image.png)
  
  - 问题场景B：抽烟者与供应商
  
  - ![](image/2023-05-15-22-16-25-image.png)

### ------------------------- 实验任务3 -------------------------

- 任务要求：哲学家就餐问题
  
  - 问题场景
  
  > 假设有5位哲学家，他们在午餐时只能思考或吃⾯。午餐时，这些哲学家共⽤⼀个圆桌，每位哲学家都坐在⼀把指定的椅⼦上。在桌⼦上放着5根筷⼦，每两根筷⼦之间都放着⼀碗葱油⾯。下⾯是⼀些约束条件：  
  > 
  > - 当⼀位哲学家处于思考状态时，他对其他哲学家不会产⽣影响。 
  > 
  > - 当⼀位哲学家感到饥饿时，他会试图拿起与他相邻的两根筷⼦。  
  > 
  > - ⼀个哲学家⼀次只能拿起⼀根筷⼦，在拿到两根筷⼦之前不会放下⼿⾥的筷⼦。  
  > 
  > - 如果筷⼦在其他哲学家⼿⾥，则需要等待。  
  > 
  > - 当⼀个饥饿的哲学家同时拥有两根筷⼦时，他会开始吃⾯。  
  > 
  > - 吃完⾯后的哲学家会同时放下两根筷⼦，并开始思考。
  
  - ⼦任务1—简单解决⽅法
  
  > 同学们需要在实验6教程的代码环境下，创建多个线程来模拟哲学家就餐的场景。然后，同学们需要结合信号量来实现理论课教材（参⻅《操作系统概念》中⽂第9版第187⻚的内容）中给出的关于哲学家就餐问题的简单解决⽅法。最后，保存结果截图并说说你是怎么做的。
  > 注意：  
  > 
  > 1. 截图结果中不能出现饥饿/死锁，可以通过输出不同哲学家的状态信息，验证你使⽤教材的⽅法确实能解决哲学家就餐问题。  
  > 2. 请将你学号的后4位包含在其中⼀个哲学家线程的输出信息中，⽤作结果截图中的个⼈信息表征。
  
  - ⼦任务2—死锁应对策略
  
  > ⼦任务1的解决⽅案保证两个相邻的哲学家不能同时进⻝，但是这种⽅案可能导致死锁。请同学们描述⼦任务1解决⽅法中会导致死锁的场景，并将其复现出来。进⼀步地，请同学们在下述4种策略中选择1种，解决⼦任务1中的死锁问题，并在代码中实现。最后，保存结果截图并说说你的实现思路。
  > 
  > - 策略1：利⽤抽屉原理（鸽笼原理）。即允许最多4个哲学家同时坐在桌⼦上，保证⾄少有1位哲学家能吃到⾯。  
  > 
  > - 策略2：利⽤AND信号量机制或信号量保护机制。仅当哲学家的左右两⽀筷⼦都可⽤时，才允许他拿起筷⼦进餐（或者说哲学家必须在临界区内拿起两根筷⼦）。  
  > 
  > - 策略3：使⽤⾮对称的解决⽅案。即规定奇数号的哲学家先拿起他左边的筷⼦，然后再去拿他右边的筷⼦；⽽偶数号的哲学家则先拿起他右边的筷⼦，然后再去拿他左边的筷⼦。按照这⼀规定，将是1、2号哲学家竞争1号筷⼦，3、4号哲学家竞争3号筷⼦。即五个哲学家都竞争奇数号筷⼦，获得后，再去竞争偶数号筷⼦，最后总会有⼀个哲学家能获得两⽀筷⼦⽽进餐。
  > 
  > - 策略4：基于管程的解决⽅法。参考理论课教材（⻅《操作系统概念》中⽂第9版190-191⻚），采⽤类似策略2的思路，定义管程来控制筷⼦的分布，控制哲学家拿起筷⼦和放下筷⼦的顺序，确保两个相邻的哲学家不会同时⽤餐。

- 思路分析：
  
  - ⼦任务1—简单解决⽅法
    
    哲学家想要进餐时，请求左右两边的筷子信号量，得到两个信号量后进餐，结束后释放左右两边筷子信号量。
  
  - ⼦任务2—死锁应对策略
    
    在哲学家请求左边的筷子信号量后，短暂延迟后再请求右边的筷子信号量。这种情况下，每位哲学家可能会在还没有能请求右边筷子信号量后，就被下一位哲学家占有该信号量，最终每个哲学家都同时拿了左边的筷子信号量，等待右边的筷子信号量，出现死锁。
    
    策略2：在每位哲学家请求筷子信号量前，先请求互斥信号量，这样就保证只要有一个哲学家进入了临界区，其它哲学家都不能请求筷子信号量，不会出现死锁。但是这种方案同一时间只能有一个哲学家进餐，效率差。
    
    策略3：使用非对称的解决方法。序号为偶数的哲学家先请求左边筷子再请求右边，为奇数的反之。这样必定有哲学家能进餐，且每次可有两位哲学家同时进餐。

- 实验步骤：
  
  - ⼦任务1—简单解决⽅法
    
    ```cpp
    void philosopher(void *arg)
    {
        int id = T;
        int left_chopstick = id;
        int right_chopstick = (id+1) % N;
        while(true)
        {
            //------------------------------拿起筷子
            chopstick[left_chopstick].P();
            printf("%d philosopher7387 get left %d chopstick.\n",id,left_chopstick);
            chopstick[right_chopstick].P();
            printf("%d philosopher7387 get right %d chopstick.\n",id,right_chopstick);
            //------------------------------进餐
            printf("- %d philosopher7387 is eating.\n",id);
            delay = 0x1fffffff;
            while(--delay){}
            //------------------------------放下筷子
            chopstick[left_chopstick].V();
            printf("%d philosopher7387 put left %d chopstick.\n",id,left_chopstick);
            chopstick[right_chopstick].V();
            printf("%d philosopher7387 put right %d chopstick.\n",id,right_chopstick);
            //-------------------------------完餐
            printf("- %d philosopher7387 has finished.\n",id);
            delay = 0x1fffffff;
            while(--delay){}
        }
    }
    
    void first_thread(void *arg)
    {
        // 第1个线程不可以返回
        stdio.moveCursor(0);
        for (int i = 0; i < 25 * 80; ++i)
        {
            stdio.print(' ');
        }
        stdio.moveCursor(0);
    
        for(int i=0;i<N;i++)
        {
            chopstick[i].initialize(1);
        }
        //-------------------------创建五个哲学家线程
        programManager.executeThread(philosopher<0>, nullptr, "p0", 1);
        programManager.executeThread(philosopher<1>, nullptr, "p1", 1);
        programManager.executeThread(philosopher<2>, nullptr, "p2", 1);
        programManager.executeThread(philosopher<3>, nullptr, "p3", 1);
        programManager.executeThread(philosopher<4>, nullptr, "p4", 1);
    
        asm_halt();
    }
    ```
  
  - ⼦任务2—死锁应对策略
    
    策略2：利⽤AND信号量机制或信号量保护机制
    
    ```cpp
        while(true)
        {
            //信号量保护机制：仅当哲学家的左右两⽀筷⼦都可⽤时，才允许他拿起筷⼦进餐
            mutex.P();
            //------------------------------拿起筷子
            chopstick[left_chopstick].P();
            printf("%d philosopher7387 get left %d chopstick.\n",id,left_chopstick);
            //拿起左筷子，在右筷子拿起前可能会被抢占，导致死锁
            delay = 0x1fffffff;
            while(--delay){}
    
            chopstick[right_chopstick].P();
            printf("%d philosopher7387 get right %d chopstick.\n",id,right_chopstick);
            //------------------------------进餐
            printf("- %d philosopher7387 is eating.\n",id);
            delay = 0x1fffffff;
            while(--delay){}
            //------------------------------放下筷子
            chopstick[left_chopstick].V();
            printf("%d philosopher7387 put left %d chopstick.\n",id,left_chopstick);
            chopstick[right_chopstick].V();
            printf("%d philosopher7387 put right %d chopstick.\n",id,right_chopstick);
            //-------------------------------完餐
            printf("- %d philosopher7387 has finished.\n",id);
            delay = 0x1fffffff;
            while(--delay){}
            mutex.V();
        }
    ```
    
    策略3：利用非对称的解决方案
    
    ```cpp
        while(true)
        {
            // 非对称解决方案
            if(T%2 == 0)//先拿左筷子再拿右筷子
            {
                chopstick[left_chopstick].P();
                printf("%d philosopher7387 get left %d chopstick.\n",id,left_chopstick);
                //拿起左筷子，在右筷子拿起前可能会被抢占，导致死锁
                delay = 0x111fffff;
                while(--delay){}
                chopstick[right_chopstick].P();
                printf("%d philosopher7387 get right %d chopstick.\n",id,right_chopstick);
            }
            else
            {
                chopstick[right_chopstick].P();
                printf("%d philosopher7387 get right %d chopstick.\n",id,right_chopstick);
                delay = 0x111fffff;
                while(--delay){}
                chopstick[left_chopstick].P();
                printf("%d philosopher7387 get left %d chopstick.\n",id,left_chopstick);
            }
            //------------------------------进餐
            printf("- %d philosopher7387 is eating.\n",id);
            delay = 0x111fffff;
            while(--delay){}
            //------------------------------放下筷子
            chopstick[left_chopstick].V();
            printf("%d philosopher7387 put left %d chopstick.\n",id,left_chopstick);
            chopstick[right_chopstick].V();
            printf("%d philosopher7387 put right %d chopstick.\n",id,right_chopstick);
            //-------------------------------完餐
            printf("- %d philosopher7387 has finished.\n",id);
            delay = 0xfffffff;
            while(--delay){}
        }
    ```

- 实验结果展示：通过执行前述代码，可得下图结果。
  
  - ⼦任务1—简单解决⽅法
    
    五位哲学家都能进餐，没有出现饥饿和死锁。
    
    ![](image/2023-05-15-21-43-55-image.png)

- ⼦任务2—死锁应对策略
  
  死锁场景
  
  每一位哲学家都拿起了左边的筷子，都在等待右边的筷子。
  
  ![](image/2023-05-14-15-17-07-image.png)
  
  死锁解决
  
  策略2：利⽤AND信号量机制或信号量保护机制
  
  每一位哲学家轮流进餐，同一时间仅有一位哲学家进餐。
  
  ![](image/2023-05-15-21-53-28-image.png)
  
  策略3：利用非对称的解决方案
  
  同一时间可有两位哲学家同时进餐。
  
  ![](image/2023-05-15-22-00-15-image.png)

## Section 4 实验总结与心得体会

通过这章学习，我对同步问题和死锁问题有了更深入的了解。对生产者-消费者、哲学家就餐模型理解得更清晰，动手实现了互斥锁、信号量，并用此解决了生产者-消费者、哲学家就餐模型问题，在实践中对理论知识有了更好的理解。

## Section 5 对实验的改进建议和意见

## Section 6 附录：参考资料清单

[互斥：原子指令&自旋锁 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/464301587)

[原子操作与 x86 上的 lock 指令前缀_x86 lock指令_zacklin的博客-CSDN博客](https://blog.csdn.net/zacklin/article/details/7445442)

[汇编指令的LOCK指令前缀 | dslztx](https://dslztx.github.io/blog/2019/06/08/%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4%E7%9A%84LOCK%E6%8C%87%E4%BB%A4%E5%89%8D%E7%BC%80/)
