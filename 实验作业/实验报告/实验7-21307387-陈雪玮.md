# 本科生实验报告

实验课程: 操作系统原理实验

任课教师: 刘宁

实验题目: **从实模式到保护模式**

专业名称: 计算机科学与技术

学生姓名: **陈雪玮**

学生学号: **21307387**

实验地点: 实验中心D501

实验时间: 2023.5.30

## Section 1 实验概述

- 学习管理资源的方法，用此实现物理地址空间的内存管理。
  
  - 位图
  
  - 地址池

- 学习并开启二级分页机制，用此是实现虚拟地址空间的内存管理。

- 开启分页机制后，程序中使用的地址是虚拟地址。我们需要结合页目录表和页表才能确定虚拟地址对应的物理地址。

## Section 2 预备知识与实验环境

该节总结实验需要用到的基本知识，以及主机型号、代码编译工具、重要三方库的版本号信息等。

- 预备知识：x86汇编语言程序设计、Linux系统命令行工具

- 实验环境：
  
  - 虚拟机版本/处理器型号：Ubuntu18.04、i386
  
  - 代码编辑环境：Linux
  
  - 代码编译工具：makefile、gcc等
  
  - 重要三方库信息：

## Section 3 实验任务

- 实验任务1：物理⻚内存管理的实现

- 实验任务2：⼆级分⻚机制的实现

- 实验任务3：虚拟⻚内存管理的实现

## Section 4 实验步骤与实验结果

### ------------------------- 实验任务1 -------------------------

- 任务要求：物理⻚内存管理的实现
  
  > 复现实验7指导书中“物理⻚内存管理”⼀节的代码，实现物理⻚内存的管理，具体要求如下：  
  > 
  > 1. 结合代码分析位图、地址池、物理⻚管理的初始化过程，以及物理⻚进⾏分配和释放的实现思路。  
  > 2. 构造测试⽤例来分析物理⻚内存管理的实现是否存在bug。如果存在，则尝试修复并再次测试。否则，结合测试⽤例简要分析物理⻚内存管理的实现的正确性。

- 思路分析：
  
  实现物理页内存管理，首先将物理内存划分为内核空间和用户空间，两个空间都有分配页、释放页和获得总容量三个方法。
  
  自顶向下看，两个空间用地址池实现，地址池是用于管理地址空间的一种数据结构，标识地址空间中页是否被分配，地址池的功能有释放页和分配页。地址池的地址空间使用位图管理，位图能够标记地址空间是否被分配，以及分配空间和释放空间。
  
  与思路类似，我们自顶向下分析初始化过程，然后分析物理页分配和释放的实现思路。
  
  首先是内存管理模块初始化，初始化这个的过程中，要初始化两个空间的地址池。初始化首先读取在实模式下获得的内存大小，然后在内存中预留部分内存存放物理地址空间页表。然后将剩余的内存等分给内核空间和用户空间。计算两个物理地址空间的起始地址，在1MB以下的空间处人为划分了存放位图的区域，得到内核空间和用户空间的位图。然后对两个空间的地址池初始化，最后将内存管理的基本信息打印出来。
  
  ```c
  void MemoryManager::initialize()
  {
      // 获取可管理内存大小
      this->totalMemory = 0;
      this->totalMemory = getTotalMemory();
  
      // 预留的内存 用来存放页表
      int usedMemory = 256 * PAGE_SIZE + 0x100000;
      if(this->totalMemory < usedMemory) {
          printf("memory is too small, halt.\n");
          asm_halt();
      }
      // 剩余的空闲的内存
      int freeMemory = this->totalMemory - usedMemory;
      // 等分给用户空间和内核空间
      int freePages = freeMemory / PAGE_SIZE;
      int kernelPages = freePages / 2;
      int userPages = freePages - kernelPages;
      // 得到两个空间的起始地址
      int kernelPhysicalStartAddress = usedMemory;
      int userPhysicalStartAddress = usedMemory + kernelPages * PAGE_SIZE;
      //得到两个空间位图管理的起始地址
      int kernelPhysicalBitMapStart = BITMAP_START_ADDRESS;
      int userPhysicalBitMapStart = kernelPhysicalBitMapStart + ceil(kernelPages, 8);
      // 地址池初始化
      kernelPhysical.initialize((char *)kernelPhysicalBitMapStart, kernelPages, kernelPhysicalStartAddress);
      userPhysical.initialize((char *)userPhysicalBitMapStart, userPages, userPhysicalStartAddress);
  
      printf("total memory: %d bytes ( %d MB )\n", 
              this->totalMemory, 
              this->totalMemory / 1024 / 1024);
  
      printf("kernel pool\n"
             "    start address: 0x%x\n"
             "    total pages: %d ( %d MB )\n"
             "    bitmap start address: 0x%x\n",
             kernelPhysicalStartAddress, 
             kernelPages, kernelPages * PAGE_SIZE / 1024 / 1024,
             kernelPhysicalBitMapStart);
  
      printf("user pool\n"
             "    start address: 0x%x\n"
             "    total pages: %d ( %d MB )\n"
             "    bit map start address: 0x%x\n",
             userPhysicalStartAddress, 
             userPages, userPages * PAGE_SIZE / 1024 / 1024,
             userPhysicalBitMapStart);
  }
  ```
  
  地址池初始化，初始化地址池时，初始化位图，然后得到地址池的起始地址。
  
  ```c
  void AddressPool::initialize(char *bitmap, const int length, const int startAddress)
  {
      resources.initialize(bitmap, length); // 管理地址池的位图初始化
      this->startAddress = startAddress;
  }
  ```
  
  位图初始化，用char作为数据类型作为一位，初始化`ceil(length,8)`长度的位图。
  
  ```c
  void BitMap::initialize(char *bitmap, const int length)
  {
      this->bitmap = bitmap;
      this->length = length;
  
      int bytes = ceil(length, 8);
      memset(bitmap, 0, bytes);
  }
  ```
  
  物理页分配，先判断分配给哪个内存空间，然后用地址池的`allocate` 函数分配`count` 大小的内存，而allocate函数使用位图中的基本操作get、set来实现。allocate分配前寻找空闲的资源下标，探取内存判断是否有足够的资源，若有，分配需要的页，然后用set将已分配的页对应的位设置为1，表示该页已分配。
  
  ```c
  int MemoryManager::allocatePhysicalPages(enum AddressPoolType type, const int count)
  {
      int start = -1;
  
      if (type == AddressPoolType::KERNEL)
      {
          start = kernelPhysical.allocate(count);
      }
      else if (type == AddressPoolType::USER)
      {
          start = userPhysical.allocate(count);
      }
  
      return (start == -1) ? 0 : start;
  }
  ```
  
  物理页释放，先判断分配给哪个内存空间，然后用地址池的`release` 函数释放内存，release使用位图的set实现，将所有位都设置位0表示资源已释放。
  
  ```c
  void MemoryManager::releasePhysicalPages(enum AddressPoolType type, const int paddr, const int count)
  {
      if (type == AddressPoolType::KERNEL)
      {
          kernelPhysical.release(paddr, count);
      }
      else if (type == AddressPoolType::USER)
      {
  
          userPhysical.release(paddr, count);
      }
  }
  ```
  
  地址池的allocate和release实现。
  
  ```cpp
  int BitMap::allocate(const int count)
  {
      if (count == 0)
          return -1;
  
      int index, empty, start;
  
      index = 0;
      while (index < length)
      {
          // 越过已经分配的资源
          while (index < length && get(index))
              ++index;
  
          // 不存在连续的count个资源
          if (index == length)
              return -1;
  
          // 找到1个未分配的资源
          // 检查是否存在从index开始的连续count个资源
          empty = 0;
          start = index;
          while ((index < length) && (!get(index)) && (empty < count))
          {
              ++empty;
              ++index;
          }
  
          // 存在连续的count个资源
          if (empty == count)
          {
              for (int i = 0; i < count; ++i)
              {
                  set(start + i, true);
              }
              return start;
          }
      }
      return -1;
  }
  
  void BitMap::release(const int index, const int count)
  {
      for (int i = 0; i < count; ++i)
      {
          set(index + i, false);
      }
  }
  ```
  
  位图中的set和get实现。
  
  ```cpp
   bool BitMap::get(const int index) const
   {
       int pos = index / 8;
       int offset = index % 8;
  
       return (bitmap[pos] & (1 << offset));
   }
  
   void BitMap::set(const int index, const bool status)
   {
       int pos = index / 8;
       int offset = index % 8;
  
       // 清0
       bitmap[pos] = bitmap[pos] & (~(1 << offset));
  
       // 置1
       if (status)
       {
           bitmap[pos] = bitmap[pos] | (1 << offset);
       }
   }
  ```

- 实验步骤
  
  **1.获取操作系统可管理的内存容量。**
  
  内存管理前，要先获取操作系统可管理的内存容量。使用实模式下功能号为`0xe801`的`15h`中断获取内存。调用方法：ax中存入0xe801，最多获取4GB内存空间。返回结果：ax存放0-15MB内存大小，单位1KB；bx存放16MB-4GB内存大小，单位64KB。$内存总容量=(ax⋅1024+bx⋅64⋅1024)bytes$
  
  保护模式下无法使用15h中断，但要在保护模式下实现内存管理的代码，这就产生了矛盾。解决方法是在实模式下获得内存大小，将内存大小写入一个固定的地址，在保护模式下从该地址中读取内存大小。
  
  实现步骤如下：
  
  修改`src/boot/mbr.asm`的代码，在实模式下，即跳转到bootloader前，调用15h中断获取内存大小，将结果写入地址0x7c00。进入保护模式，在first_thread读取内存大小。
  
  **2.位图**
  
  位图是用于资源管理的一种数据结构，使用一位和一个资源单元建立映射关系，一般使用1表示资源已分配，0表示资源空闲。
  
  实现位图，即实现一个数据结构。成员有：位图大小、位图管理的资源单元数量；方法有：单独和批处理存、取位。
  
  **3.地址池**
  
  地址池是用于管理地址空间的一种数据结构，标识地址空间中页是否被分配，可以释放页和分配页。
  
  地址池的地址管理使用位图实现，来标记页是否被分配。
  
  **4.物理页内存管理**
  
  物理内存划分为两部分：内核空间、用户空间。现在所有的代码运行在内核空间下，用户空间的概念实现进程后才好理解。
  
  每一个程序都有一个独立的用户空间，里面存放可执行代码、数据、栈等等。开启分页机制后，代码中使用的地址是虚拟地址，CPU根据虚拟地址和MMU自动将虚拟地址转换为物理地址，最终CPU访问的是物理地址。
  
  通过分页机制，同一个虚拟地址能映射到不同的物理地址。进程和内核都有各自的目录表和页表，因此能保证这些空间不发生冲突。
  
  为了有效隔离内核和用户程序的物理地址空间，整个物理地址空间划分为两部分，内核空间和用户空间。内核需要的物理页只从内核空间中分配，用户程序需要的物理页只从用户空间中分配。
  
  在操作系统实现中，用两个地址池分别对两部分物理地址进行管理。
  
  **5.构造测试用例**
  
  分别对内核空间和用户空间都构造测试用例，测试分配和释放页后，位图设置、地址是否正确。
  
  测试用例构造如下：
  
  1. 查看未分配时位图状态，此时都是0。
  
  2. 连续分配两个页，得到分配的起始地址address1。
  
  3. 分配一个页，得到分配的起始地址address2。
  
  4. 查看分配后的位图状态，此时页0、1、2是1，页3是0。
  
  5. 查看两个起始地址，计算它们的差，为两个页大小8192KB。
  
  6. 从address1开始释放两个页。
  
  7. 查看释放后的位图状态，此时只有页2是1，其余都是0。
  
  8. 连续分配两个页，得到分配的起始地址address3。
  
  9. 此时address3等于address1。
  
  若结果符合以上测试用例，则物理页内存管理能够正确执行。
  
  测试内核空间代码如下，用户空间思路相同在第一个线程中执行。
  
  ```cpp
  void test(enum AddressPoolType type)
  {   
      int page0 = memoryManager.kernelPhysical.resources.get(0);
      int page1 = memoryManager.kernelPhysical.resources.get(1);
      int page2 = memoryManager.kernelPhysical.resources.get(2);
      int page3 = memoryManager.kernelPhysical.resources.get(3);
      printf("before allocation:\n");
      printf("page0:%d page1:%d page2:%d page3:%d\n",page0,page1,page2,page3);
      // 分配页
      int address1 = memoryManager.allocatePhysicalPages(type,2);// 得到的是分配空间的起始地址
      int address2 = memoryManager.allocatePhysicalPages(type,1);
      page0 = memoryManager.kernelPhysical.resources.get(0);
      page1 = memoryManager.kernelPhysical.resources.get(1);
      page2 = memoryManager.kernelPhysical.resources.get(2);
      page3 = memoryManager.kernelPhysical.resources.get(3);
      printf("after allocation:\n");
      printf("page0:%d page1:%d page2:%d page3:%d\n",page0,page1,page2,page3);
      printf("address1:%d address2:%d address2-address1=%d\n",address1,address2,(address2-address1));
      // 释放页
      memoryManager.releasePhysicalPages(type,address1,2);
      page0 = memoryManager.kernelPhysical.resources.get(0);
      page1 = memoryManager.kernelPhysical.resources.get(1);
      page2 = memoryManager.kernelPhysical.resources.get(2);
      page3 = memoryManager.kernelPhysical.resources.get(3);
      int address3 = memoryManager.allocatePhysicalPages(type,2);
      printf("after release:\n");
      printf("page0:%d page1:%d page2:%d page3:%d\n",page0,page1,page2,page3);
      printf("address3:%d==address1:%d\n",address3,address1);
      memoryManager.releasePhysicalPages(type,address3,2);
  }
  
  void first_thread(void *arg)
  {
      // 构造测试物理页内存管理的测试用例 
      printf("------------------------------------------------\n");
      printf("21307387_cxw physical MMU Test.\n");
      printf("KERNEL:\n");
      test(AddressPoolType::KERNEL);
      printf("USER:\n");
      test(AddressPoolType::USER);
      asm_halt();
  }
  ```

- 实验结果展示：通过执行前述代码，可得下图结果。
  
  ![](image/2023-05-25-18-22-41-image.png)
  
  ![](image/2023-05-25-18-30-27-image.png)

### ------------------------- 实验任务2 -------------------------

- 任务要求：⼆级分⻚机制的实现

> 复现实验7指导书中“⼆级分⻚机制”⼀节的代码，实现⼆级分⻚机制，具体要求如下：  
> 
> 1. 实现内存的申请和释放，保存实验截图并对并能够在虚拟机地址空间中进⾏内存管理，截图并给出过程解释（⽐如：说明哪些输出信息描述虚拟地址，哪些输出信息描述物理地址）。注意：建议使⽤的物理地址或虚拟地址信息与学号相关联（⽐如学号后四位作为⻚内偏移），作为报告独⽴完成的个⼈信息表征。  
> 
> 2. 相⽐于⼀级⻚表，⼆级⻚表的开销是增⼤的，但操作系统中往往使⽤的是⼆级⻚表⽽不是⼀级⻚表。结合你⾃⼰的实验过程，说说相⽐于⼀级⻚表，使⽤⼆级⻚表会带来哪些优势。

- 思路分析：
  
  1. 开启二级分页机制.
  
  2. 实现虚拟页内存管理,实现内存的申请和释放.

- 实验步骤:
  
  **1.为什么要实现分页机制？**
  
  计算机内存容量有限，因此要决定哪些程序可以放入内存，哪些放在外存。除此之外，实现多线程和多进程后，要确保它们无法访问对方的地址空间，实现内存保护。
  
  因此要了解两点：
  
  - 程序如何装入内存？
    
    一份C代码经过编译、汇编、链接后形成可执行程序，可执行程序放在外存，被加载到内存才能执行。程序从外存加载到内存的过程称为程序的**装入**。
    
    > - 注意，程序编译后，默认起始地址是0。
    > 
    > - C语言的**全局变量**都是偏移地址，kernel是被加载到0x20000​处执行的。因此使用`ld`​链接时，要加上-Ttext 0x00020000​参数，表明起始地址是0x20000。
    > 
    > - C语言的**局部变量**翻译成的汇编代码是使用ebp和esp来访问的，因此不会出错。
    
    装入方式有三种：
    
    - 绝对装入。**编译**时产生绝对地址。
    
    - 静态重定位。**装入**时将逻辑地址转换为物理地址。
    
    - 动态重定位。**运行**时通过MMU（内存管理单元）将逻辑地址转换为物理地址，可以改变MMU的内容来得到不同的转换方式，因此相同的逻辑地址可以映射到不同的物理地址。
      
      二级分页机制能够有效地帮助我们来进行程序的动态重定位。
  
  - 内存保护如何实现？
    
    进程是程序运行时的映像，不同的进程的虚拟地址都是从0开始一直到4GB。但是这些进程却不会发生冲突。原因在于每一个进程都有一个独立的地址空间和页表，通过不同的地址映射机制，即通过不同的页表和页目录表，可以将相同的虚拟地址变换到不同的物理地址，从而解决了冲突，实现内存保护机制。
  
  **2.分页机制是什么？（一级页表、二级页表）**
  
  - 一级页表
  
  分页机制下，内存被划分为大小相等的内存块，每个内存块称为页。在此实验中，一个页大小为4KB。
  
  开启分页机制前，物理地址=段地址+偏移地址（保护模式、分段机制）。
  
  开启分页机制后，虚拟地址=段地址+偏移地址（分段机制）。MMU将虚拟地址转换为物理地址。MMU集成在CPU中，程序运行过程给出的是虚拟地址，CPU通过页部件将其自动转换为物理地址。
  
  一级页表先通过虚拟地址在页表中找到对应的页表项，然后再根据页表项给出的页地址和页内偏移找到实际的物理地址。
  
  一个地址有32位，低12位用作页内偏移，高20位用作页表项索引，于是页表项共有$2^{20}=1M$项，每个页表项大小位4B，因此一张页表大小为4MB，可以表示$1M\times 4KB=4GB$的内存，也就是32位的地址空间。
  
  **一个页表项大小4B，共1M个页表项，高20位是页表项索引，低12位是页内偏移。**
  
  一级页表的虚拟地址到物理地址的转换如下。
  
  > - 取虚拟地址高20位乘4，与页表项4KB大小对齐得到页表项的地址。
  > 
  > - 取虚拟地址低12位页内偏移，加上从页表项索引得到的物理地址得到要访问的物理地址。
  
  - 二级页表
  
  但是一级页表有以下问题:
  
  > - 页表必须连续存放，当页表很大时需要占用很多内存。
  > 
  > - 没必要让整个页表常驻内存，因为进程在一段时间内可能只访问几个特定的页面。
  
  一般有两种解决方法：二级页表（页目录表）、虚拟存储技术。下面介绍二级页表。
  
  二级页表就是借用分页机制的思想，我们也为页表创建页表。这个“页表的页表”被称为页目录表，页目录表中的每一项被称为页目录项，页目录项的内容是页表的物理地址。通过页目录表来访问页表，然后通过页表访问物理页的方式被称为二级分页机制。
  
  一个地址有32位，页大小为4KB=$2^{12}$KB，取低12位作为页内偏移。在二级页表机制下，页目录表、页表、物理页的大小均为4KB，每个页目录项和页表项大小都为4B。
  
  页目录表中的页目录项有4KB/4B=1024个​，每一个页目录项对应了一个页表，因此我们有1024个页表。在每一个页表中，页表项的数目为4KB/4B=1024。每一个页表项的对应一个物理页，因此1024个页目录表对应的物理页数有1024*1024=1M个，一张页表大小为4KB，可以表示1M\*4KB=4GB的内存，也就是32位的地址空间。
  
  **3.开启二级页表分页机制**
  
  启动分页机制流程如下
  
  > - 规划好页目录表和页表在内存中的位置，然后初始化。
  > - 将页目录表的地址写入cr3。
  > - 将cr0的PG位置1。
  
  **4.实现内存的申请和释放**
  
  即开启虚拟页内存管理，步骤如下,实验任务三中有详细描述.
  
  > 1. 在MMU中添加虚拟地址池成员管理虚拟地址,并进行初始化.
  > 
  > 2. 实现页内存分配,分为三步.
  >    
  >    - 从虚拟地址池中分配若干连续的虚拟页。
  >    - 对每一个虚拟页，从物理地址池中分配1页。
  >    - 为虚拟页建立页目录项和页表项，使虚拟页内的地址经过分页机制变换到物理页内。
  >      3- 实现页内存释放,分为两步:
  >    - 对每一个虚拟页，释放为其分配的物理页。
  >    - 释放虚拟页。
  
  **页内存分配**
  
  ```cpp
  int MemoryManager::allocatePages(enum AddressPoolType type, const int count)
  {
      // 第一步：从虚拟地址池中分配若干虚拟页
      int virtualAddress = allocateVirtualPages(type, count);
      if (!virtualAddress)
      {
          return 0;
      }
  
      bool flag;
      int physicalPageAddress;
      int vaddress = virtualAddress;
  
      // 依次为每一个虚拟页指定物理页
      for (int i = 0; i < count; ++i, vaddress += PAGE_SIZE)
      {
          flag = false;
          // 第二步：从物理地址池中分配一个物理页
          physicalPageAddress = allocatePhysicalPages(type, 1);
          if (physicalPageAddress)
          {
              //printf("allocate physical page 0x%x\n", physicalPageAddress);
  
              // 第三步：为虚拟页建立页目录项和页表项，使虚拟页内的地址经过分页机制变换到物理页内。
              flag = connectPhysicalVirtualPage(vaddress, physicalPageAddress);
          }
          else
          {
              flag = false;
          }
  
          // 分配失败，释放前面已经分配的虚拟页和物理页表
          if (!flag)
          {
              // 前i个页表已经指定了物理页
              releasePages(type, virtualAddress, i);
              // 剩余的页表未指定物理页
              releaseVirtualPages(type, virtualAddress + i * PAGE_SIZE, count - i);
              return 0;
          }
      }
      // 成功分配后, 打印分配地址
      printf("successfully allocate %d pages.\n",count);
      printf("physical address:%x\n",physicalPageAddress);
      printf("virtual address:%x\n",virtualAddress);
      printf("\n");
      return virtualAddress;
  }
  ```
  
  **页内存释放**
  
  ```cpp
  void MemoryManager::releasePages(enum AddressPoolType type, const int virtualAddress, const int count)
  {
    int vaddr = virtualAddress;
    int *pte;
    for (int i = 0; i < count; ++i, vaddr += PAGE_SIZE)
    {
        // 第一步，对每一个虚拟页，释放为其分配的物理页
        releasePhysicalPages(type, vaddr2paddr(vaddr), 1);
  
        // 设置页表项为不存在，防止释放后被再次使用
        pte = (int *)toPTE(vaddr);
        *pte = 0;
    }
  
    // 第二步，释放虚拟页
    releaseVirtualPages(type, virtualAddress, count);
    printf("virtual address %x successfully release.\n\n",virtualAddress);
  }
  ```
  
  **在第一个线程中分配和释放虚拟也表**
  
  ```cpp
  void first_thread(void *arg)
  {
  
    //虚拟页表分配
    char *p1 = (char *)memoryManager.allocatePages(AddressPoolType::KERNEL, 2);
    char *p2 = (char *)memoryManager.allocatePages(AddressPoolType::KERNEL, 2);
  
    //虚拟页表释放,释放第一次分配的两页内存
    memoryManager.releasePages(AddressPoolType::KERNEL, (int)p1, 2);
    asm_halt();
  }实验结果展示：通过执行前述代码，可得下图结果。
  ```

- 实验结果展示：通过执行前述代码，可得下图结果。
  1.虚拟内存的分配和释放实验截图如下.
  
  **页内存分配**
  
  ![](image/2023-06-02-21-05-14-image.png)
  
  **页内存释放**
  
  ![](image/2023-06-02-21-10-54-image.png)
  
  2.结合实验过程来看，相⽐于⼀级⻚表，使⽤⼆级⻚表的好处如下。
  
  > 1. 节省空间：在一级页表中，每个进程都需要占用一个完整的页表空间。而在二级页表中，只有当进程实际需要使用到某个页时，才会分配对应的页表，并且每个页表本身也可以根据需要动态调整大小，能够节省大量的空间。
  > 
  > 2. 方便管理：使用二级页表可以更方便地管理内存空间，因为不同的进程可以共享同一个页表。例如，多个进程可能具有相同的代码段或数据段，这些进程可以共享同一个页表，从而减少重复的存储。
  > 
  > 3. 更加灵活：使用二级页表可以更灵活地管理内存空间。例如，在一级页表中，如果进程的地址空间非常大，可能需要使用非常大的页表。而使用二级页表可以根据需要分配多个小型页表，这样就能够更灵活地管理内存空间。
  > 
  > 总的来说，使用二级页表可以带来更高效的内存管理和更灵活的内存空间分配，这是一级页表所没有的优势。

### ------------------------- 实验任务3 -------------------------

- 任务要求：虚拟⻚内存管理的实现

> 复现实验7指导书中“虚拟⻚内存管理”⼀节的代码，实现虚拟⻚内存的管理，具体要求如下：  
> 
> 1. 结合代码，描述虚拟⻚内存**分配**的三个基本步骤，以及虚拟⻚内存**释放**的过程。  
> 2. 构造测试⽤例来分析虚拟⻚内存管理的实现是否存在bug。如果存在，则尝试修复并再次测试。否则，结合测试⽤例简要分析虚拟⻚内存管理的实现的正确性。  
> 3. 在PDE（⻚⽬录项）和 PTE（⻚表项）的虚拟地址构造中，我们使⽤了第1023个⻚⽬录项。**第1023个⻚⽬录项指向了⻚⽬录表本身，从⽽使得我们可以构造出PDE和PTE的虚拟地址**。现在，我们将这个指向⻚⽬录表本身的⻚⽬录项放⼊第1000个⻚⽬录项，⽽不再是放⼊了第1023个⻚⽬录项。请同学们借助第1000个⻚⽬录项，构造出第141个⻚⽬录项的虚拟地址，和第891个⻚⽬录项指向的⻚表中第109个⻚表项的虚拟地址。

- 思路分析：
  
  1.虚拟页内存分配三个步骤如下.。
  
  > - 从虚拟地址池中分配**连续的**多个虚拟页。
  > - 从物理地址池中为每一个虚拟页分配相应大小的物理页。**（不一定连续）**
  > - 在页目录表和页表中建立虚拟页和物理页之间的对应关系。
  
  2.构造测试用例的思路是分配和释放虚拟页表并观察相应的虚拟地址和物理地址是否符合预期结果。

- 实验步骤：
  
  **1.初始化**
  
  在开启分页机制后，程序使用的地址空间是虚拟地址空间。CPU会使用MMU来自动地将虚拟地址转换成物理地址。
  
  为了实现内存管理，对于虚拟地址空间中的地址，我们也需要通过一个地址池来进行管理。这个地址池被称为虚拟地址池。我们将用户（进程）看到的地址空间称为用户虚拟地址空间，将内核看到的地址空间称为内核虚拟地址空间。因此，我们可以有多个用户虚拟地址池和一个内核虚拟地址池。
  
  每一个进程都有自己的虚拟地址池，因此用户虚拟地址池放在PCB中，不是全局变量。内存管理器MemoryManager只关心全局地址空间，即用户物理地址空间、内核虚拟地址空间、内核物理地址空间。
  
  因此对应三个地址池：kernelPhysical​、kernelVirtual​、userPhysical​。
  
  我们在实验任务2的基础上添加代码。
  
  > - MemoryManager​成员中加入内核虚拟地址池。
  > 
  > - 修改MemoryManager::initialize​，加入初始化内核虚拟地址池kernelVirtual​的代码。
  
  **2.页内存分配**
  
  因此，页内存分配分为以下3步。
  
  - 从虚拟地址池中分配若干连续的虚拟页。
  
  - 对每一个虚拟页，从物理地址池中分配一页。
  
  - 为虚拟页建立页目录项和页表项，使虚拟页内的地址经过分页机制变换到物理页内。
  
  ---
  
  - **从虚拟地址池中分配若干连续的虚拟页,对每一个虚拟页，从物理地址池中分配一页。**
  
  页内存分配函数如下。首先使用`allocateVirtualPages`从虚拟地址吃中分配若干连续的虚拟页，然后使用`allocatePhysicalPages`依次为每一个虚拟页分配物理页。分配成功，则使用`connectPhysicalVirtualPage`虚拟页建立目录项和页表项，使虚拟地址经过分页机制变换到物理页内；分配失败，则释放前面已经分配的虚拟页和物理页。分配成功过返回虚拟页首地址，分配失败返回0。
  
  以上的分配和释放函数都是使用地址池的分配和释放操作实现。
  
  ```cpp
  int MemoryManager::allocatePages(enum AddressPoolType type, const int count)
  {
      // 第一步：从虚拟地址池中分配若干虚拟页
      int virtualAddress = allocateVirtualPages(type, count);
      if (!virtualAddress) // 如果虚拟页已经满了
      {
          return 0;
      }
  
      bool flag;
      int physicalPageAddress; // 物理页地址
      int vaddress = virtualAddress; //虚拟页地址
  
      // 依次为每一个虚拟页指定物理页
      for (int i = 0; i < count; ++i, vaddress += PAGE_SIZE)
      {
          flag = false;
          // 第二步：从物理地址池中分配一个物理页
          physicalPageAddress = allocatePhysicalPages(type, 1);
          if (physicalPageAddress) // 如果有足够的物理页可以被分配
          {
              //printf("allocate physical page 0x%x\n", physicalPageAddress);
  
              // 第三步：为虚拟页建立页目录项和页表项，使虚拟页内的地址经过分页机制变换到物理页内。
              flag = connectPhysicalVirtualPage(vaddress, physicalPageAddress);
          }
          else
          {
              flag = false;
          }
  
          // 分配失败，释放前面已经分配的虚拟页和物理页表
          if (!flag)
          {
              // 前i个页表已经指定了物理页
              releasePages(type, virtualAddress, i);
              // 剩余的页表未指定物理页
              releaseVirtualPages(type, virtualAddress + i * PAGE_SIZE, count - i);
              return 0;
          }
      }
      return virtualAddress;
  }
  ```
  
  - **为虚拟页建立页目录项和页表项，使虚拟页内的地址经过分页机制变换到物理页内。**
    
    函数实现如下。
  
  ```cpp
  bool MemoryManager::connectPhysicalVirtualPage(const int virtualAddress, const int physicalPageAddress)
  {
      // 计算虚拟地址对应的页目录项和页表项
      int *pde = (int *)toPDE(virtualAddress);
      int *pte = (int *)toPTE(virtualAddress);
  
      // 页目录项无对应的页表，先分配一个页表
      if(!(*pde & 0x00000001)) 
      {
          // 从内核物理地址空间中分配一个页表
          int page = allocatePhysicalPages(AddressPoolType::KERNEL, 1);
          if (!page)
              return false;
  
          // 使页目录项指向页表
          *pde = page | 0x7;
          // 初始化页表
          char *pagePtr = (char *)(((int)pte) & 0xfffff000);
          memset(pagePtr, 0, PAGE_SIZE);
      }
  
      // 使页表项指向物理页
      *pte = physicalPageAddress | 0x7;
  
      return true;
  }
  ```
  
  为了访问虚拟地址空间下的页目录项和页表项，我们需要**根据页目录项和页表项将页目录项和页表项的虚拟地址构造出来**。我们主要解决如下两个问题。
  
  - 根据页目录项的序号构造出页目录项的虚拟地址。
  - 根据页目录项和页表项的序号构造出页表项的虚拟地址。
  
  对于一个虚拟地址，我们需要构造三部分的信息，页目录号virtual[31:22]，页号virutal[21:12]和偏移地址virtual[11:0]。
  
  在开启分页机制的时候，我们设置最后一个页目录项指向了页目录表。所以我们可以利用这个页目录项完成pde和pte的构造.
  
  构造的具体方法代码如下.
  
  ```cpp
  int toPDE(const int virtualAddress)
  {
      return (0xfffff000 + (((virtualAddress & 0xffc00000) >> 22) * 4));
  }
  
  int toPTE(const int virtualAddress)
  {
      return (0xffc00000 + ((virtualAddress & 0xffc00000) >> 10) + (((virtualAddress & 0x003ff000) >> 12) * 4));
  }
  ```
  
  构造好虚拟地址对应的pde和pte后，我们便可以**建立虚拟页到物理页的映射。**
  
  首先，我们检查pde中是否有对应的页表。如果没有，就要先分配一个物理页，然后初始化新分配的物理页并将其地址写入pde，以作为pde指向的页表。在pde对应的物理页存在的前提下，我们将之前为虚拟页分配的物理页地址写入pte即可。
  
  ```cpp
  bool MemoryManager::connectPhysicalVirtualPage(const int virtualAddress, const int physicalPageAddress)
  {
      // 计算虚拟地址对应的页目录项和页表项
      int *pde = (int *)toPDE(virtualAddress);
      int *pte = (int *)toPTE(virtualAddress);
  
      // 页目录项无对应的页表，先分配一个页表
      if(!(*pde & 0x00000001)) 
      {
          // 从内核物理地址空间中分配一个页表
          int page = allocatePhysicalPages(AddressPoolType::KERNEL, 1);
          if (!page)
              return false;
  
          // 使页目录项指向页表
          *pde = page | 0x7;
          // 初始化页表
          char *pagePtr = (char *)(((int)pte) & 0xfffff000);
          memset(pagePtr, 0, PAGE_SIZE);
      }
  
      // 使页表项指向物理页
      *pte = physicalPageAddress | 0x7;
  
      return true;
  }
  ```
  
  **3.页内存释放**
  
  页内存的释放是页内存分配的过程，分两个步骤完成。
  
  - 对每一个虚拟页，释放为其分配的物理页。
  - 释放虚拟页。
  
  ```cpp
  void MemoryManager::releasePages(enum AddressPoolType type, const int virtualAddress, const int count)
  {
      int vaddr = virtualAddress;
      int *pte;
      for (int i = 0; i < count; ++i, vaddr += PAGE_SIZE)
      {
          // 第一步，对每一个虚拟页，释放为其分配的物理页
          releasePhysicalPages(type, vaddr2paddr(vaddr), 1);
  
          // 设置页表项为不存在，防止释放后被再次使用
          pte = (int *)toPTE(vaddr);
          *pte = 0;
      }
  
      // 第二步，释放虚拟页
      releaseVirtualPages(type, virtualAddress, count);
      printf("virtual address %x successfully release.\n\n",virtualAddress);
  }
  ```
  
  **4.构造测试用例**
  
  主要测试是否能正确分配和释放页内存和物理内存,以及**连续的虚拟地址能否映射到不连续的物理地址**.
  
  测试用例构造思路如下.
  
  > 1. 依次分配三次内存,100页,10页,100页.
  > 
  > 2. 释放第二次分配的10页.
  > 
  > 3. 依次分配两次内存,100页,10页.
  > 
  > 4. 正确的结果是
  >    
  >    - 三次分配后,虚拟地址和物理地址都是连续的.然后释放了10页后再分配100页.
  >    
  >    - 对物理地址来说,无法在原来释放10页的位置完全分配.那么就应该先分配10页后,剩下的90页将从最后一次分配的物理地址继续分配.
  >    
  >    - 对虚拟地址来说,依旧是连续分配,所以会将从最后一次分配的虚拟地址继续分配.
  > 
  > 5. 满足预期结果,可以说明分配正确,连续的虚拟页分配可以对应不连续的物理页分配.
  
  在第一个线程中构造测试用例,代码如下.
  
  ```cpp
  void first_thread(void *arg)
  {
      // 分配内存
      char *p1 = (char *)memoryManager.allocatePages(AddressPoolType::KERNEL, 100);
      char *p2 = (char *)memoryManager.allocatePages(AddressPoolType::KERNEL, 10);
      char *p3 = (char *)memoryManager.allocatePages(AddressPoolType::KERNEL, 100);
  
      //释放内存
      memoryManager.releasePages(AddressPoolType::KERNEL, (int)p2, 10);
  
      // 再分配内存 这里是关键 可以得到连续的虚拟页可以映射到不连续的物理页的结果
      char * p4 = (char *)memoryManager.allocatePages(AddressPoolType::KERNEL, 100);
      char * p5 = (char *)memoryManager.allocatePages(AddressPoolType::KERNEL, 10);
  
      asm_halt();
  }
  ```

- 实验结果展示：通过执行前述代码，可得下图结果。
1. 构造测试⽤例来分析虚拟⻚内存管理的实现是否存在bug,结合测试⽤例简要分析虚拟⻚内存管理的实现的正确性。
   
   ![](image/2023-06-02-22-03-59-image.png)

2. 借助第1000个⻚⽬录项，构造出第141个⻚⽬录项的虚拟地址，和第891个⻚⽬录项指向的⻚表中第109个⻚表项的虚拟地址。
   
   **构造思路如下**
   
   - 构造PDE
     
     首先，页目录项所在的物理页是页目录表，virtual的页目录号是virtual[31:22]，而每一个页目录项的大小是4个字节，因此页内偏移为
     
     $$
     pde[11:0]=4×virtual[31:22] \\
virtual = (4*141)_{10} = 1000110100_2\\
pde[11:0]=001000110100_2
     $$
     
     接下来我们构造pde[21:12]。pde是位于页目录表的，那么，在现有的页表中，哪一个页表中的哪一个页表项指向了页目录表呢？实际上，页目录表是页表的一种特殊形式，页目录表的第1000个页目录项指向了页目录表。因此我们有
     
     $$
     pde[21:12]=1000_{10}=1111101000_2
     $$
     
     最后，我们来构造pde[31:22]。在构造pde[21:12]的时候，我们把页目录表当成了页表，而pde[31:22]是页目录项的序号，我们需要知道页目录表的哪一个页目录项指向了这个“页表”。显然，答案是第1000个页表项，因此我们有
     
     $$
     pde[31:22]=1000_{10}=1111101000_2
     $$
     
     最后，得到pde为
     
     $$
     pde=11111010001111101000001000110100_2=fa3e8234_{16}
     $$
   
   - 构造PTE
     
     首先，页表项所在的物理页是页表，virtual的页号是virtual[21:12]，而每一个页表项的大小是4个字节，因此我们有
     
     $$
     pte[11:0]=4×virtual[21:12]\\
virtual = (4*109)_{10} = 110110100_2\\
pte[11:0]=000110110100_2
     $$
     
     接下来我们构造pte[21:12]。pte是位于页表的，那么，在现有的页表中，哪一个页表的哪一个页表项指向了pte所在的页表呢？回忆起二级分页机制的地址变换过程我们发现，页目录表的第virutal[31:22]个页目录项指向了这个页表，因此我们有
     
     $$
     pte[21:12]=virtual[31:22]=891_{10}=0001101101_2\\
virtual=891_10=1101111011_2\\
pte[21:12]=1101111011_2
     $$
     
     最后，我们来构造pde[31:22]。我们实际上把页目录表当成了页表，而pte[31:22]是页目录项的序号，我们需要知道页目录表的哪一个页表项指向了这个“页表”显然，答案是第1000个页表项，因此我们有
     
     $$
     pte[31:22]=1000_{10}=1111101000_2
     $$
     
     最后，得到pte为
     
     $$
     pte=11111010001101111011000110110100_2=fa37b1b4_{16}
     $$

## Section 5 实验总结与心得体会

这个实验主要是关于内存管理的。我对使用两级分页机制学习虚拟地址空间的资源管理方法和内存管理有了更深入的理解。

我学习了两种管理资源的方法，即位图和地址池。其中，位图是管理资源的常用方法，它可以将每个物理内存块的对应位设置为0或1，从而很容易找到可用的内存块；另一方面，地址池将物理内存块划分为几个固定大小的块，每个块都有一个唯一的编号，允许根据编号快速搜索可用内存块。这些方法可以用来实现物理地址空间的内存管理。

我学习并启动了两级分页机制，并在此基础上实现了虚拟地址空间的内存管理。启用分页机制后，程序中使用的地址为虚拟地址，需要与页面目录表和页面表相结合，确定虚拟地址对应的物理地址。

这个实验加深了我对虚拟内存管理的理解。我不仅学习了不同的资源管理方法，还学习了如何使用两级分页机制进行虚拟页内存管理。

## Section 6 对实验的改进建议和意见

## Section 7 附录：参考资料清单
