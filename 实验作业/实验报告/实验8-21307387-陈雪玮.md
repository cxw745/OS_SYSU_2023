# 本科生实验报告

实验课程: 操作系统原理实验

任课教师: 刘宁

实验题目: **从用户态到内核态**

专业名称: 计算机科学与技术

学生姓名: **陈雪玮**

学生学号: **21307387**

实验地点: 实验中心D501

实验时间: 2023.6.15

## Section 1 实验概述

- 学习保护模式下特权级的相关内容.

- 学习系统调用的概念和如何通过中断来实现系统调用.

- 实现系统调用后,通过三步创建进程.

- 重点理解如何通过分页机制实现进程之间的虚拟地址空间的隔离.

- 学习fork/wait/exit的一种简洁的实现思路。

## Section 2 预备知识与实验环境

该节总结实验需要用到的基本知识，以及主机型号、代码编译工具、重要三方库的版本号信息等。

- 预备知识：x86汇编语言程序设计、Linux系统命令行工具

- 实验环境：
  
  - 虚拟机版本/处理器型号：Ubuntu18.04、i386
  
  - 代码编辑环境：Linux
  
  - 代码编译工具：makefile、gcc等
  
  - 重要三方库信息：

## Section 3 实验任务

- 实验任务1：复现指导书中“系统调⽤的实现”⼀节，并回答以下问题...

- 实验任务2：复现“进程的实现”、“进程的调度”、“第⼀个进程”三节，并回答以下问题...

- 实验任务3：复现“fork”⼀⼩节的内容，并回答以下问题...

- 实验任务4：参考指导书中“wait”和“exit”两节的内容，实现 wait 函数和 exit 函数，回答以下问题...

## Section 4 实验步骤与实验结果

### ------------------------- 实验任务1 -------------------------

- 任务要求：复现指导书中“系统调⽤的实现”⼀节，并回答以下问题。  
  
  1. 请解释为什么需要使⽤寄存器来传递系统调⽤的参数，以及我们是如何在执⾏ `int 0x80` 前在栈中找到参数并放⼊寄存器的。  
  2. 请使⽤gdb来分析在我们调⽤了` int 0x80 `后，系统的栈发⽣了怎样的变化？` esp `的值和在` setup.cpp `中定义的变量` tss` 有什么关系？此外还有哪些段寄存器发⽣了变化？变化后的内容是什么？  
  3. 请使⽤gdb来分析在进⼊ `asm_system_call_handler` 的那⼀刻，栈顶的地址是什么？栈中存放的内容是什么？为什么存放的是这些内容？  
  4. 请结合代码分析` asm_system_call_handler` 是如何找到中断向量号 `index` 对应的函数的。  
  5. 请使⽤gdb来分析在` asm_system_call_handler `中执⾏` iret` 后，哪些段寄存器发⽣了变化？变化后的内容是什么？这些内容来⾃于什么地⽅？

- 思路分析：
  
  1. 定义并实现系统调用函数,其中要实现0x80中断函数,将从用户态进入内核态，由操作系统内核来完成这些服务，然后再从内核态返回用户态，最后得到服务的结果。
  
  2. 定义并实现系统调用管理类,创建并调用系统调用函数.
  
  3. 创建系统调用管理类,使用它调用系统调用函数.

- 实验步骤：
  
  操作系统为了限制程序访问特权资源，于是将程序的执行限制在特权级3下，称为用户态。但是，操作系统会向程序提供一系列服务的约定，如访问磁盘、内存分配和输入输出等。此时，为了使用这些服务，程序需要通过中断、调用等方式从用户态进入内核态，由操作系统内核来完成这些服务，然后再从内核态返回用户态，最后得到服务的结果。整个过程被称为系统调用，system call。
  
  在我们的系统中，系统调用就是调用软中断、中断处理和中断返回这一过程。
  
  1. 系统调用的入口函数声明如下.
     
     ```cpp
     extern "C" int asm_system_call(int index, int first = 0, \
     int second = 0, int third = 0, int forth = 0, int fifth = 0);
     ```
     
     系统调用的参数不可以超过五个,五个参数通过寄存器来传递.
     
     `asm_system_call`是通过汇编来实现的，如下所示。
     
     ```nasm
     asm_system_call:
         push ebp
         mov ebp, esp
         
         push ebx
         ...
         ;保护现场,将系统调用的参数放到5个寄存器,参数从右到左入栈
         ;ebx, ecx, edx, esi, edi中，将系统调用号放到eax中
         mov eax, [ebp + 2 * 4] ;index
         mov ebx, [ebp + 3 * 4] ;first
         mov ecx, [ebp + 4 * 4] ;second
         mov edx, [ebp + 5 * 4] ;third
         mov esi, [ebp + 6 * 4] ;forth
         mov edi, [ebp + 7 * 4] ;fifth   
         ;调用0x80中断,根据保存在eax的系统调用号来调用不同的函数
         int 0x80
         ;恢复现场
         pop gs
         ...
     
         ret
     ```
  
  2. 创建管理系统调用的类`SystemService`.具体实现在代码中.
     
     ```cpp
     #ifndef SYSCALL_H
     #define SYSCALL_H
     
     #include "os_constant.h"
     
     class SystemService
     {
     public:
         SystemService();
         // 初始化中应加入0x80对应的中断描述符
         void initialize();
         // 设置系统调用，index=系统调用号，function=处理第index个系统调用函数的地址
         bool setSystemCall(int index, int function);
     };
     
     // 第0个系统调用,打印输入的5个参数，最后返回这5个参数的和。
     int syscall_0(int first, int second, int third, int forth, int fifth);
     
     #endif
     ```
  
  3. 实现`0x80`号中断的处理函数.
     
     ```nasm
     asm_system_call_handler:
         ;保护现场
         push ds
         push es
         push fs
         push gs
         pushad
     
         push eax
     
         ; 栈段会从tss中自动加载
     
         mov eax, DATA_SELECTOR
         mov ds, eax
         mov es, eax
     
         mov eax, VIDEO_SELECTOR
         mov gs, eax
     
         pop eax
     
         ; 参数压栈
         push edi
         push esi
         push edx
         push ecx
         push ebx
         ;开中断,调用系统调用处理的函数,函数返回值在eax中
         sti    
         call dword[system_call_table + eax * 4]
         cli
         ;压入栈的五个参数弹出栈
         add esp, 5 * 4
         ;将函数返回值保存在[ASM_TEMP]中
         mov [ASM_TEMP], eax
         popad
         ;恢复现场
         pop gs
         pop fs
         pop es
         pop ds
         mov eax, [ASM_TEMP]
         
         iret
     ```
  
  4. 实现系统调用号为0的系统调用并在内核启动后调用.
     
     ```cpp
     int syscall_0(int first, int second, int third, int forth, int fifth)
     {
         printf("systerm call 0: %d, %d, %d, %d, %d\n",
                first, second, third, forth, fifth);//打印五个参数
         return first + second + third + forth + fifth;//返回五个参数的和
     }
     ```
     
     调用方法
     
     ```cpp
     ret = asm_system_call(0, 123, 324, 9248);
     printf("return value: %d\n", ret);
     ```

- 实验结果展示：通过执行前述代码，可得下图结果。 ![](image/2023-06-15-21-13-12-image.png)
  
  - **从低特权级向高特权级转移**。从低特权级向高特权级转移是通过中断、调用等方式来实现的，但这里我们只使用中断的方式来实现特权级转移。程序通过使用`int`指令来调用指定的中断，然后中断描述符中的代码段选择子会被加载到CS寄存器中，从而改变了CPL，实现特权级转移。
  - **从高特权级向低特权级转移**。从高特权级转移向低特权级转移只能通过中断返回和调用返回来实现。
  1. 因为用户程序使用系统调用时会从低特权级转移到高特权级,如果使用栈来传递参数,系统调用的参数将被保存在用户程序的栈中,CPU从TSS中加载高特权级的栈地址到esp寄存器.C语言代码编译后使用esp和ebp访问栈的参数,此时访问的就是高特权级的栈,CPU就无法找到保存在低特权级中的参数.因此,需要使用寄存器来传递系统调用的参数,使得CPU能得到传入的参数.
     
     在调用`int 0x80`中断前,ebp寄存器入栈,将栈基址(存在esp中的值)存入ebp,通过相对栈基址的偏移,我们可以得到参数列表从右到左的每个参数,然后我们将将系统调用的参数放到5个寄存器ebx, ecx, edx, esi, edi中，将系统调用号放到eax中。
  
  2. `int 0x80`中断处理函数会根据保存在eax的系统调用号来调用不同的函数,因此我们会从低特权级向高特权级转移，这时CPU先在TSS中找到栈选择子和栈指针(`TSS::ss0`和`TSS::esp0`)，然后送入`ss`，`esp`。因此系统的栈会从低特权级的栈转移向高特权级的栈,esp中存储的栈地址改变,ss中存储的栈指针改变.此外,还有cs段寄存器发生了更改.
     
     ![](image/2023-06-16-10-30-38-image.png)
     
     ![](image/2023-06-16-10-35-02-image.png)
  
  3. 栈顶的地址存放在esp,进入中断处理函数时,栈顶地址是TSS的`esp0`,为栈段从TSS中自动加载.
     
     栈中存放的内容有ds,es,fs,gs寄存器,因为中断发生后只更改了cs寄存器,这四个寄存器没有修改,因此在调用系统调用函数前需要手动修改这些寄存器;有edi,esi,edx,ecx,ebx寄存器,这五个寄存器保存系统调用函数的五个参数;有eax,系统调用号保存在eax,并且系统调用函数的返回值保存在eax.
     
     ![](image/2023-06-16-10-31-43-image.png)
  
  4.  开中断后,调用系统调用处理的函数.系统调用号`index`保存在eax中,`system_call_table`保存着系统调用处理函数的地址,每一个元素占4个字节.因此通过`[system_call_table + eax * 4]`就能找到中断向量号`index`对应的函数.
     
     ```nasm
     ...
     sti    
     call dword[system_call_table + eax * 4]
     cli
     ...
     ```
  
  5. 执行`iret`后,从高特权级转向低特权级.cs段寄存器发生了变化,变化后的内容为32,这个内容来自低特权级的栈.
     
     ![](image/2023-06-16-10-52-57-image.png)
     
     ![](image/2023-06-16-10-53-23-image.png)

### ------------------------- 实验任务2 -------------------------

- 任务要求：
  
  复现“进程的实现”、“进程的调度”、“第⼀个进程”三节，并回答以下问题。
  
  1. 请结合代码分析我们是如何在线程的基础上创建进程的PCB的（即分析进程创建的三个步骤）。  
  2. 在进程的PCB第⼀次被调度执⾏时，进程实际上并不是跳转到进程的第⼀条指令处，⽽是跳转到 load_process 。请结合代码逻辑和gdb来分析为什么 asm_switch_thread 在执⾏ iret 后会跳转到 load_process 。  
  3. 在跳转到 load_process 后，我们巧妙地设置了 ProcessStartStack 的内容，然后在 asm_start_process 中跳转到进程第⼀条指令处执⾏。请结合代码逻辑和gdb来分析我们是如何设置 ProcessStartStack 的内容，从⽽使得我们能够在 asm_start_process 中实现内核态到⽤户态的转移，即从特权级0转移到特权级3下，并使⽤ iret 指令成功启动进程的。  
  4. 结合代码，分析在创建进程后，我们对 ProgramManager::schedule 作了哪些修改？这样做的⽬的是什么？  
  5. 在进程的创建过程中，我们存在如下语句
     
     ```cpp
     int ProgramManager::executeProcess(const char *filename, int priority)
     {
     ...
     // 找到刚刚创建的PCB
     PCB *process = ListItem2PCB(allPrograms.back()， tagInAllList);
     ...
     
     }
     ```
     
     正如教程中所提到，“……但是，这样做是存在风险的，我们应该通过pid来找到刚刚创建的PCB。……”。现在，同学们需要编写一个`ProgramManager`的成员函数`findProgramByPid`
     
     ```cpp
     PCB *findProgramByPid(int pid);
     ```
     
     并用上面这个函数替换提到的"存在风险的语句"，替换结果如下。
     
     ```cpp
     int ProgramManager::executeProcess(const char *filename, int priority)
     {
         ...
         // 找到刚刚创建的PCB
         PCB *process = findProgramByPid(pid);
         ...
     }
     ```
     
     自行测试通过后，将结果截图并说说你是怎么做的。

- 思路分析：
  
  1. 为进程创建前作准备,包括将3GB-4GB的虚拟地址映射到0-1MB的空间和初始化TSS和用户段描述符.
  
  2. 创建进程.
  
  3. 实现进程的调度.
  
  4. 调用第一个进程.

- 实验步骤：
  
  1. 通过分页机制将3GB-4GB的虚拟地址空间映射到0~1MB的空间.
     
     使用时钟中断时,`programManager`的虚拟地址是0-1MB,与进程的虚拟地址冲突,因此我们将3-4GB的虚拟地址空间作为共享的内核区域,通过分页机制映射到0-1MB的物理地址,使得进程也能访问到内核的资源.为了使进程能够对`programmerManager`进行正确寻址，我们需要在链接时指定代码中的变量是相对于`0xc0000000`偏移的，我们将makefile修改如下。
     
     ```makefile
     ...
     
     kernel.bin : kernel.o
     	objcopy -O binary kernel.o kernel.bin
     	
     kernel.o : entry.obj $(OBJ)
     	$(LINKER) -o kernel.o -melf_i386 -N entry.obj $(OBJ) -Ttext 0xc0020000 -e enter_kernel
     
     ...
     ```
     
     修改之后,为了让CPU能正确寻址,需要在跳转到内核之前开启分页机制,即在`bootloader`中开启分页机制.
     
     ```nasm
     ...
     ;调用开启分页机制函数,代码在src/boot/page.cpp
     call open_page_mechanism
     ; 将页目录表地址放入eax中
     mov eax, PAGE_DIRECTORY
     mov cr3, eax ; 放入页目录表地址
     mov eax, cr0
     or eax, 0x80000000
     mov cr0, eax ; 置PG=1，开启分页机制
     ;之前保存在GDTR的GDT地址还是位于0~1MB的空间中，
     ;因此我们要将其加上偏移量0xc0000000，
     ;使其地址也提升到3-4GB,然后再送入到GDTR中
     sgdt [pgdt]
     add dword[pgdt + 2], 0xc0000000
     lgdt [pgdt]
     
     jmp dword CODE_SELECTOR:KERNEL_VIRTUAL_ADDRESS; 跳转到kernel
     ...
     ```
     
     删掉`bootloader.asm`开头的`org`伪指令，然后修改makefile中生成bootloader.bin的代码.
     
     将`os_constant.h`中的地址也提升到3GB以上的空间,将显存访问地址提升到3GB以上的空间。
  
  2. 初始化TSS和用户段描述符.
     
     向`ProgramManager`中加入存储3个代码段、数据段和栈段描述符的变量。初始化这些段描述符,要注意的是,之前段描述符的DPL是0,而这三个描述符的DPL是3,然后将这些段描述符送入GDT.
     
     ```cpp
     class ProgramManager
     {
     public:
         List allPrograms;        // 所有状态的线程/进程的队列
         List readyPrograms;      // 处于ready(就绪态)的线程/进程的队列
         PCB *running;            // 当前执行的线程
         int USER_CODE_SELECTOR;  // 用户代码段选择子
         int USER_DATA_SELECTOR;  // 用户数据段选择子
         int USER_STACK_SELECTOR; // 用户栈段选择子
         ...
     }
     ```
     
     初始化TSS.当我们从低特权级向高特权级转移时，CPU首先会在TSS中找到高特权级栈的段选择子和栈指针，然后送入SS，ESP。此时，栈发生变化，此时的栈已经变成了TSS保存的高特权级的栈。接着，中断发生前的SS、ESP、EFLAGS、CS、EIP被依次压入了高特权级栈。因此，TSS的作用仅限于向CPU提供进程特权级转移时的栈段选择子和栈指针。
     
     因此，TSS的作用仅限于向CPU提供进程特权级转移时的栈段选择子和栈指针。
     
     TSS的内容必须如此安排，因为CPU规定了TSS中的内容。如果不做上述安排，当CPU加载TSS时就会加载到错误的数据。
     
     TSS 和其他段一样，本质上是一片存储数据的内存区域， Intel本来是想让操作系统使用这片内存区域保存任务的最新状态，因此它也像其他段那样，有对应的段描述符，称为TSS 描述符.
     
     CPU是在特权级转移的时候自动加载TSS的内容的，因此CPU需要有一个地方来保存TSS描述符的选择子，以便于CPU在发生特权级切换时能自动加载TSS中的内容。这个地方被称为TR寄存器。我们使用`ltr`将TSS的段选择子送入TR即可。
     
     ```cpp
     #ifndef TSS_H
     #define TSS_H
     
     struct TSS
     {
     public:
         int backlink;
         int esp0;
         int ss0;
         int esp1;
         int ss1;
         int esp2;
         int ss2;
         int cr3;
         int eip;
         int eflags;
         int eax;
         int ecx;
         int edx;
         int ebx;
         int esp;
         int ebp;
         int esi;
         int edi;
         int es;
         int cs;
         int ss;
         int ds;
         int fs;
         int gs;
         int ldt;
         int trace;
         int ioMap;
     };
     #endif
     ```
     
     由于TSS的作用仅限于提供0特权级下的栈指针和栈段选择子，因此我们关心`TSS::ss0`和`TSS::esp0`。但在这里我们只对`TSS::ss0`进行复制，`TSS::esp0`会在进程切换时更新。此时，TSS的初始化如下。
     
     ```cpp
     void ProgramManager::initializeTSS()
     {
     
         int size = sizeof(TSS);
         int address = (int)&tss;
     
         memset((char *)address, 0, size);
         tss.ss0 = STACK_SELECTOR; // 内核态堆栈段选择子
     
         int low, high, limit;
     
         limit = size - 1;
         low = (address << 16) | (limit & 0xff);
         // DPL = 0
         high = (address & 0xff000000) | ((address & 0x00ff0000) >> 16) | ((limit & 0xff00) << 16) | 0x00008900;
     
         int selector = asm_add_global_descriptor(low, high);
         // RPL = 0
         asm_ltr(selector << 3);
         tss.ioMap = address + size;
     }
     ```
  
  3. 创建进程.
     
     进程的创建分为3步。
     
     - 创建进程的PCB。
     - 初始化进程的页目录表。
     - 初始化进程的虚拟地址池。
     
     首先,在PCB中新增以下内容,用于实现分页机制.
     
     ```cpp
     struct PCB
     {
     	...
         int pageDirectoryAddress;            // 页目录表地址
         AddressPool userVirtual;             // 用户程序虚拟地址池
     };
     ```
     
     然后实现创建进程的函数`ProgramManager::executeProcess`.
     
     第7-13行，我们像创建一个线程一样创建进程的PCB。这里，创建线程的参数并不是进程的起始地址，而是加载进程的函数。如果进程创建失败，将其状态标记为`DEAD`.
     
     第16行，将刚刚创建的PCB加入到`allPrograms`的末尾。
     
     第19-25行，我们为进程创建页目录表。页目录表的创建和初始化通过`ProgramManager::createProcessPageDirectory`来实现.
     
     第28-35行，我们为进程创建虚拟地址池，通过`ProgramManager::createUserVirtualPool`实现.
     
     ```cpp
     int ProgramManager::executeProcess(const char *filename, int priority)
     {
         bool status = interruptManager.getInterruptStatus();
         interruptManager.disableInterrupt();
     
         // 在线程创建的基础上初步创建进程的PCB
         int pid = executeThread((ThreadFunction)load_process,
                                 (void *)filename, filename, priority);
         if (pid == -1)
         {
             interruptManager.setInterruptStatus(status);
             return -1;
         }
     
         // 找到刚刚创建的PCB
         PCB *process = ListItem2PCB(allPrograms.back()， tagInAllList);
     
         // 创建进程的页目录表
         process->pageDirectoryAddress = createProcessPageDirectory();
         if (!process->pageDirectoryAddress)
         {
             process->status = ThreadStatus::DEAD;
             interruptManager.setInterruptStatus(status);
             return -1;
         }
     
         // 创建进程的虚拟地址池
         bool res = createUserVirtualPool(process);
     
         if (!res)
         {
             process->status = ThreadStatus::DEAD;
             interruptManager.setInterruptStatus(status);
             return -1;
         }
     
         interruptManager.setInterruptStatus(status);
     
         return pid;
     }
     ```
     
     `ProgramManager::createProcessPageDirectory`如下所示。
     
     第4-9行，我们从内核中分配一页来存储进程的页目录表,与为线程分配页的方法一样.
     
     第11-19行，我们令用户虚拟地址的3GB-4GB的空间指向内核空间。
     
     第22行，我们将最后一个页目录项指向用户进程页目录表物理地址，这是为了我们在切换到用户进程后，我们也能够构造出页目录项和页表项的虚拟地址。
     
     ```cpp
     int ProgramManager::createProcessPageDirectory()
     {
         // 从内核地址池中分配一页存储用户进程的页目录表
         int vaddr = memoryManager.allocatePages(AddressPoolType::KERNEL, 1);
         if (!vaddr)
         {
             //printf("can not create page from kernel\n");
             return 0;
         }
     
         memset((char *)vaddr, 0, PAGE_SIZE);
     
         // 复制内核目录项到虚拟地址的高1GB
         int *src = (int *)(0xfffff000 + 0x300 * 4);
         int *dst = (int *)(vaddr + 0x300 * 4);
         for (int i = 0; i < 256; ++i)
         {
             dst[i] = src[i];
         }
     
         // 用户进程页目录表的最后一项指向用户进程页目录表本身
         ((int *)vaddr)[1023] = memoryManager.vaddr2paddr(vaddr) | 0x7;
         
         return vaddr;
     }
     ```
     
     `ProgramManager::createUserVirtualPool`的实现如下,创建的方法与之前创建内核虚拟地址池类似,要注意的是虚拟地址空间需要提升到3GB以上.
     
     ```cpp
     bool ProgramManager::createUserVirtualPool(PCB *process)
     {
         // 计算这部分地址所占页表的数量
         int sourcesCount = (0xc0000000 - USER_VADDR_START) / PAGE_SIZE;
         int bitmapLength = ceil(sourcesCount, 8);
     
         // 计算位图所占的页数
         int pagesCount = ceil(bitmapLength, PAGE_SIZE);
     
         int start = memoryManager.allocatePages(AddressPoolType::KERNEL, pagesCount);
     
         if (!start)
         {
             return false;
         }
         //初始化用户虚拟地址池
         memset((char *)start, 0, PAGE_SIZE * pagesCount);
         (process->userVirtual).initialize((char *)start, bitmapLength, USER_VADDR_START);
     
         return true;
     }
     ```
  
  4. 实现进程调度.
     
     在线程调度的基础上加入如下部分.
     
     - 切换页目录表.
     
     - 更新TSS中的特权级0的栈.
     
     ```cpp
     void ProgramManager::schedule()
     {
          ...//增加内容如下
              
         activateProgramPage(next);
     
         asm_switch_thread(cur, next);
     
         interruptManager.setInterruptStatus(status);
     }
     void ProgramManager::activateProgramPage(PCB *program)
     {
         int paddr = PAGE_DIRECTORY;
     
         if (program->pageDirectoryAddress)
         {
             tss.esp0 = (int)program + PAGE_SIZE;
             paddr = memoryManager.vaddr2paddr(program->pageDirectoryAddress);
         }
     
         asm_update_cr3(paddr);
     }
     ```
  
  5. 创建并执行第一个进程.
     
     该进程调用之前的0号系统调用.代码如下.
     
     ```cpp
     void first_process()
     {
         asm_system_call(0, 132, 324, 12, 124, 21307387);
         asm_halt();
     }
     
     void first_thread(void *arg)
     {
         printf("start process\n");
         programManager.executeProcess((const char *)first_process, 1);
         programManager.executeProcess((const char *)first_process, 1);
         programManager.executeProcess((const char *)first_process, 1);
         asm_halt();
     }
     
     extern "C" void setup_kernel()
     {
     
         // 中断管理器
         interruptManager.initialize();
         interruptManager.enableTimeInterrupt();
         interruptManager.setTimeInterrupt((void *)asm_time_interrupt_handler);
     
         // 输出管理器
         stdio.initialize();
     
         // 进程/线程管理器
         programManager.initialize();
     
         // 内存管理器
         memoryManager.initialize();
     
         // 初始化系统调用
         systemService.initialize();
         // 设置0号系统调用
         systemService.setSystemCall(0, (int)syscall_0);
     
         // 创建第一个线程
         int pid = programManager.executeThread(first_thread, nullptr, "first thread", 1);
         if (pid == -1)
         {
             printf("can not execute thread\n");
             asm_halt();
         }
     
         ListItem *item = programManager.readyPrograms.front();
         PCB *firstThread = ListItem2PCB(item,tagInGeneralList);
         firstThread->status = RUNNING;
         programManager.readyPrograms.pop_front();
         programManager.running = firstThread;
         asm_switch_thread(0, firstThread);
     
         asm_halt();
     }
     ```

- 实验结果展示：通过执行前述代码，可得下图结果。
  
  ![](image/2023-06-15-21-46-57-image.png)
  
  1. 在实验步骤创建进程部分有详细分析.
  
  2. `load_process`的作用是在从高特权级向低特权级转移前,将进程需要的段选择子信息放入栈中.`asm_switch_thread`会进行进程切换,执行新的进程,在执行前,需要先跳转到`load_process`将段选择子信息放入栈中.
     
     我们定义了一个类`ProgramStartStack`来表示启动进程之前栈放入的内容,将其放在PCB的顶部空间,因此当进程的PCB被首次加载时,先初始化该类,因此当`asm_switch_thread`切换时会先进入`load_process`.
     
     在PCB的顶部预留出`ProcessStartStack`的空间
     
     当我们从低特权级向高特权级转移时，CPU首先会在TSS中找到高特权级栈的段选择子和栈指针，然后送入SS，ESP。此时，栈发生变化，此时的栈已经变成了TSS保存的高特权级的栈。接着，中断发生前的SS、ESP、EFLAGS、CS、EIP被依次压入了高特权级栈。
     
     TSS的作用仅限于向CPU提供进程特权级转移时的栈段选择子和栈指针。
     
     由于TSS的作用仅限于提供0特权级下的栈指针和栈段选择子，因此我们关心`TSS::ss0`和`TSS::esp0`。但在这里我们只对`TSS::ss0`进行复制，`TSS::esp0`会在进程切换时更新。
  
  3.  在函数`load_process`中,们在进程虚拟地址空间中分配一页来作为进程的特权级3栈,代码如下.
     
     ```cpp
     interruptStack->esp = memoryManager.allocatePages(AddressPoolType::USER, 1);
     ```
     
     然后我们将`ProcessStartStack`的起始地址送入了esp，然后通过一系列的pop指令和iret语句更新寄存器，最后中断返回后，特权级3的选择子被放入到段寄存器中，代码跳转到进程的起始处执行。代码以及注释如下.
     
     ```nasm
     ; void asm_start_process(int stack);
     asm_start_process:
         ;得到各个分配的虚拟页的地址,即ProcessStartStack的起始地址,
         mov eax, dword[esp+4]
         ;将其送入esp
         mov esp, eax
         popad
         pop gs;
         pop fs;
         pop es;
         pop ds;
     
         iret
     ```
  
  4.  修改是增加了切换页目录表和更新TSS中的特权级0的栈.切换页目录表的目的是使得各进程间的虚拟地址映射到物理地址后地址不冲突;更新TSS中的特权级0的栈的目的是使得进程切换后,能够正确地进行系统调用函数的使用.
     
     ```cpp
     void ProgramManager::schedule()
     {
          ...//增加内容如下
              
         activateProgramPage(next);
     
         asm_switch_thread(cur, next);
     
         interruptManager.setInterruptStatus(status);
     }
     ```
  
  5.  实现思路是在所有的进程队列中逐个寻找,直到找到相同pid的PCB,将其返回,代码如下.
     
     ```cpp
     PCB* ProgramManager::findProgramByPid(int pid)
     {
         ListItem* t = allPrograms.at(0);//得到所有进程队列的头指针
         PCB* cur = ListItem2PCB(t, tagInAllList);
         while(t!=nullptr)//逐个寻找
         {
             if(cur->pid==pid)
             {
                 printf("successfully find pid %d PCB\n",pid);
                 return cur;
             }
             t = t->next;
             cur = ListItem2PCB(t, tagInAllList);
         }
     }
     ```
     
     ![](image/2023-06-16-21-04-03-image.png)

### ------------------------- 实验任务3 -------------------------

- 任务要求：
  
  复现“fork”⼀⼩节的内容，并回答以下问题：  
  
  1. 请根据代码逻辑概括 fork 的实现的基本思路，并简要分析我们是如何解决"四个关键问题"的。  
  2. 请根据gdb来分析⼦进程第⼀次被调度执⾏时，即在 asm_switch_thread 切换到⼦进程的栈中时， esp 的地址是什么？栈中保存的内容是什么？  
  3. 从⼦进程第⼀次被调度执⾏时开始，逐步跟踪⼦进程的执⾏流程⼀直到⼦进程从 fork 返回，根据gdb来分析⼦进程的跳转地址、数据寄存器和段寄存器的变化。同时，⽐较上述过程和⽗进程执⾏完 ProgramManager::fork 后的返回过程的异同。  
  4. 请根据代码逻辑和gdb来解释⼦进程的 fork 返回值为什么是0，⽽⽗进程的 fork 返回值是⼦进程的pid。  
  5. 请解释在 ProgramManager::schedule 中，我们是如何从⼀个进程的虚拟地址空间切换到另外⼀个进程的虚拟地址空间的。

- 思路分析：
  
  fork的实现可以细化为4个问题的解决。
  
  1. 如何实现父子进程的代码段共享？
  2. 如何使得父子进程从相同的返回点开始执行？
  3. 除代码段外，进程包含的资源有哪些？
  4. 如何实现进程的资源在进程之间的复制？

- 实验步骤：
  
  fork的实现通过`ProgramManager::fork`来完成.
  
  ```cpp
  int ProgramManager::fork()
  {
      bool status = interruptManager.getInterruptStatus();
      interruptManager.disableInterrupt();
  
      // 禁止内核线程调用
      PCB *parent = this->running;
      if (!parent->pageDirectoryAddress)
      {
          interruptManager.setInterruptStatus(status);
          return -1;
      }
  
      // 创建子进程
      int pid = executeProcess("", 0);
      if (pid == -1)
      {
          interruptManager.setInterruptStatus(status);
          return -1;
      }
  
      // 初始化子进程
      PCB *child = ListItem2PCB(this->allPrograms.back(Pr), tagInAllList);
      
      //最关键的部分,资源的复制
      bool flag = copyocess(parent, child);
  
      if (!flag)
      {
          child->status = ProgramStatus::DEAD;
          interruptManager.setInterruptStatus(status);
          return -1;
      }
  
      interruptManager.setInterruptStatus(status);
      return pid;
  }
  ```

- 实验结果展示：通过执行前述代码，可得下图结果。
  
  ![](image/2023-06-16-21-20-41-image.png)
  
  1. fork实现的基本思路是,首先,fork是进程的系统调用,因此先禁止内核线程调用;然后调用`ProgramManager::executeProcess`创建一个子进程;接着,初始化子进程,调用`ProgramManager::copyProcess`来复制父进程的资源到子进程中.
     
     解决四个关键问题的方法如下:
     
     1. 我们使用函数来模拟一个进程，而函数的代码是放在内核中的，进程又划分了3GB~4GB的空间来实现内核共享，因此进程的代码就是共享的。
     
     2. 我们会复制父进程的3特权级栈到子进程的3特权级栈中，而3特权级栈保存了父进程在执行`int 0x80`后的逐步返回的返回地址。因此，父子进程的逐步返回的地址是相同的，从而实现了在执行fork后，父子进程从相同的点返回。
     
     3. 在我们的操作系统中，进程包含的资源有0特权级栈，PCB、虚拟地址池、页目录表、页表及其指向的物理页。
     
     4. 我们首先在父进程的虚拟地址空间下将数据复制到中转页中，再切换到子进程的虚拟地址空间中，然后将中转页复制到子进程对应的位置。
  
  2. esp的地址和栈中保存内容如下图所示.![](image/2023-06-16-23-31-13-image.png)
  
  3.  相同点是它们返回的地址是相同的,相异点是它们的返回值不同.
  
  4. 在fork的实现中,父进程会得到子进程的pid,从而返回子进程的pid.
     
     ```cpp
         // 创建子进程    int pid = executeProcess("", 0);
         if (pid == -1)
         {
             interruptManager.setInterruptStatus(status);
             return -1;
         }
     
         // 初始化子进程
         PCB *child = ListItem2PCB(this->allPrograms.back(), tagInAllList);
         bool flag = copyProcess(parent, child);
     
         if (!flag)
         {
             child->status = ProgramStatus::DEAD;
             interruptManager.setInterruptStatus(status);
             return -1;
         }
     
         interruptManager.setInterruptStatus(status);
         return pid;;
     ```
     
     复制父进程0特权栈给子进程时,我们将子进程的eax设置为0，使得在子进程中的fork返回值为0.
     
     ```cpp
         // 复制进程0级栈
         ProcessStartStack *childpss =
             (ProcessStartStack *)((int)child + PAGE_SIZE - sizeof(ProcessStartStack));
         ProcessStartStack *parentpss =
             (ProcessStartStack *)((int)parent + PAGE_SIZE - sizeof(ProcessStartStack));
         memcpy(parentpss, childpss, sizeof(ProcessStartStack));
         // 设置子进程的返回值为0
         childpps->eax = 0;
     ```
  
  5. 在 ProgramManager::schedule 中,我们先通过`activateProgramPage(next)`将当前进程的页目录表切换为下一个进程的页目录表,然后通过`asm_switch_thread(cur, next)`将当前进程切换为下一个进程,就完成了从⼀个进程的虚拟地址空间切换到另外⼀个进程的虚拟地址空间.

### ------------------------- 实验任务4 -------------------------

- 任务要求：
  
  参考指导书中“wait”和“exit”两节的内容，实现 wait 函数和 exit 函数，回答以下问题：  
  
  1. 请结合代码逻辑和具体的实例来分析 exit 的执⾏过程。  
  2. 请解释进程退出后能够隐式调⽤ exit 的原因。（tips：从栈的⻆度分析）  
  3. 请结合代码逻辑和具体的实例来分析 wait 的执⾏过程。
  4. 如果⼀个⽗进程先于⼦进程退出，那么⼦进程在退出之前会被称为孤⼉进程。⼦进程在退出后，从状态被标记为 DEAD 开始到被回收，⼦进程会被称为僵⼫进程。请对代码做出修改，实现回收僵⼫进程的有效⽅法。

- 思路分析：
  
  exit的实现主要分为三步。
  
  1. 标记PCB状态为`DEAD`并放入返回值。
  2. 如果PCB标识的是进程，则释放进程所占用的物理页、页表、页目录表和虚拟地址池bitmap的空间。否则不做处理。
  3. 立即执行线程/进程调度。
  
  wait根据定义实现.
  
  1. wait的参数`retval`用来存放子进程的返回值，如果`retval==nullptr`，则说明父进程不关心子进程的返回值。
  
  2. wait的返回值是被回收的子进程的pid。如果没有子进程，则wait返回`-1`。
  
  3. 在父进程调用了wait后，如果存在子进程但子进程的状态不是`DEAD`，则父进程会被阻塞，即wait不会返回直到子进程结束。

- 实验步骤：
  
  exit的实现如下.
  
  ```cpp
  void ProgramManager::exit(int ret)
  {
      // 关中断
      interruptManager.disableInterrupt();
      
      // 第一步，标记PCB状态为`DEAD`并放入返回值。
      PCB *program = this->running;
      program->retValue = ret;
      program->status = ProgramStatus::DEAD;
  
      int *pageDir, *page;
      int paddr;
  
      // 第二步，如果PCB标识的是进程，则释放进程所占用的物理页、页表、页目录表和虚拟地址池bitmap的空间。
      if (program->pageDirectoryAddress)
      {
          pageDir = (int *)program->pageDirectoryAddress;
          for (int i = 0; i < 768; ++i)
          {
              if (!(pageDir[i] & 0x1))
              {
                  continue;
              }
  
              page = (int *)(0xffc00000 + (i << 12));
  
              for (int j = 0; j < 1024; ++j)
              {
                  if(!(page[j] & 0x1)) {
                      continue;
                  }
  
                  paddr = memoryManager.vaddr2paddr((i << 22) + (j << 12));
                  memoryManager.releasePhysicalPages(AddressPoolType::USER, paddr, 1);
              }
  
              paddr = memoryManager.vaddr2paddr((int)page);
              memoryManager.releasePhysicalPages(AddressPoolType::USER, paddr, 1);
          }
  
          memoryManager.releasePages(AddressPoolType::KERNEL, (int)pageDir, 1);
          
          int bitmapBytes = ceil(program->userVirtual.resources.length, 8);
          int bitmapPages = ceil(bitmapBytes, PAGE_SIZE);
  
          memoryManager.releasePages(AddressPoolType::KERNEL,
                                     (int)program->userVirtual.resources.bitmap, 
                                     bitmapPages);
  
      }
  
      // 第三步，立即执行线程/进程调度。
      schedule();
  }
  ```
  
  wait的实现如下.
  
  ```cpp
  int ProgramManager::wait(int *retval)
  {
      PCB *child;
      ListItem *item;
      bool interrupt, flag;
  
      while (true)
      {
          interrupt = interruptManager.getInterruptStatus();
          interruptManager.disableInterrupt();
  
          item = this->allPrograms.head.next;
  
          // 查找子进程
          flag = true;
          while (item)
          {
              child = ListItem2PCB(item, tagInAllList);
              if (child->parentPid == this->running->pid)
              {
                  flag = false;
                  if (child->status == ProgramStatus::DEAD)
                  {
                      break;
                  }
              }
              item = item->next;
          }
  
          if (item) // 找到一个可返回的子进程
          {
              if (retval)
              {
                  *retval = child->retValue;
              }
  
              int pid = child->pid;
              releasePCB(child);
              interruptManager.setInterruptStatus(interrupt);
              return pid;
          }
          else 
          {
              if (flag) // 子进程已经返回
              {
                  
                  interruptManager.setInterruptStatus(interrupt);
                  return -1;
              }
              else // 存在子进程，但子进程的状态不是DEAD
              {
                  interruptManager.setInterruptStatus(interrupt);
                  schedule();
              }
          }
      }
  }
  ```

- 实验结果展示：通过执行前述代码，可得下图结果。
  
  ![](image/2023-06-16-21-55-17-image.png)
  
  ![](image/2023-06-16-21-53-58-image.png)
  
  1.  exit的执行分为三步.
     
     1. 标记PCB状态为`DEAD`并放入返回值。
     
     2. 如果PCB标识的是进程，则释放进程所占用的物理页、页表、页目录表和虚拟地址池bitmap的空间。否则不做处理。
     
     3. 立即执行线程/进程调度。
     
     ```cpp
     void ProgramManager::exit(int ret)
     {
         // 关中断
         interruptManager.disableInterrupt();
         
         // 第一步，标记PCB状态为`DEAD`并放入返回值。
         PCB *program = this->running;
         program->retValue = ret;
         program->status = ProgramStatus::DEAD;
     
         int *pageDir, *page;
         int paddr;
     
         // 第二步，如果PCB标识的是进程，则释放进程所占用的物理页、页表、页目录表和虚拟地址池bitmap的空间。
         if (program->pageDirectoryAddress)
         {
             pageDir = (int *)program->pageDirectoryAddress;
             for (int i = 0; i < 768; ++i)
             {
                 if (!(pageDir[i] & 0x1))
                 {
                     continue;
                 }
     
                 page = (int *)(0xffc00000 + (i << 12));
     
                 for (int j = 0; j < 1024; ++j)
                 {
                     if(!(page[j] & 0x1)) {
                         continue;
                     }
     
                     paddr = memoryManager.vaddr2paddr((i << 22) + (j << 12));
                     memoryManager.releasePhysicalPages(AddressPoolType::USER, paddr, 1);
                 }
     
                 paddr = memoryManager.vaddr2paddr((int)page);
                 memoryManager.releasePhysicalPages(AddressPoolType::USER, paddr, 1);
             }
     
             memoryManager.releasePages(AddressPoolType::KERNEL, (int)pageDir, 1);
             
             int bitmapBytes = ceil(program->userVirtual.resources.length, 8);
             int bitmapPages = ceil(bitmapBytes, PAGE_SIZE);
     
             memoryManager.releasePages(AddressPoolType::KERNEL,
                                        (int)program->userVirtual.resources.bitmap, 
                                        bitmapPages);
     
         }
     
         // 第三步，立即执行线程/进程调度。
         schedule();
     }
     ```
  
  2.  因为我们在进程的3特权级栈的顶部放入exit的地址和参数,栈的读取从顶部开始,因此,当执行进程的函数退出后,就会跳转到栈的顶部,进程就会主动跳转到exit,使得进程退出后能够隐式调⽤`exit`.
  
  3.  首先在所有的进程队列中寻找状态为DEAD的子进程,找到一个后判断参数`retvall`,如果`retval`不为`nullptr`，取出子进程的返回值放入到`retval`指向的变量中。然后取出子进程的pid，调用`releasePCB`来回收子进程的PCB，最后返回子进程的pid;如果没有找到子进程,就返回-1.如果存在子进程但其状态不是DEAD,就执行调度.即父进程会被阻塞，wait不会返回直到子进程结束。
     
     ```cpp
     int ProgramManager::wait(int *retval)
     {
         PCB *child;
         ListItem *item;
         bool interrupt, flag;
     
         while (true)
         {
             interrupt = interruptManager.getInterruptStatus();
             interruptManager.disableInterrupt();
     
             item = this->allPrograms.head.next;
     
             // 查找子进程
             flag = true;
             while (item)
             {
                 child = ListItem2PCB(item, tagInAllList);
                 if (child->parentPid == this->running->pid)
                 {
                     flag = false;
                     if (child->status == ProgramStatus::DEAD)
                     {
                         break;
                     }
                 }
                 item = item->next;
             }
     
             if (item) // 找到一个可返回的子进程
             {
                 if (retval)
                 {
                     *retval = child->retValue;
                 }
     
                 int pid = child->pid;
                 releasePCB(child);
                 interruptManager.setInterruptStatus(interrupt);
                 return pid;
             }
             else 
             {
                 if (flag) // 子进程已经返回
                 {
                     
                     interruptManager.setInterruptStatus(interrupt);
                     return -1;
                 }
                 else // 存在子进程，但子进程的状态不是DEAD
                 {
                     interruptManager.setInterruptStatus(interrupt);
                     schedule();
                 }
             }
         }
     }
     ```
  
  4.  查看子进程的父亲进程状态,如果为DEAD或者查找不到,则为将之进程,将其回收.

## Section 5 实验总结与心得体会

在这次实验中,我学习到了如何创建,调度,执行用户进程,并且学习了系统调⽤的概念和通过中断实现系统调⽤的⽅法,以及用户进程怎么调用系统调用函数.除此之外,还学习了 fork/wait/exit 的⼀种简洁的实现思路。通过以上内容的学习,我对用户态到内核态的转换有了更深入的理解,也明白了进程之间是如何通过分页机制实现进程之间的虚拟地址空间的隔离的.

## Section 6 对实验的改进建议和意见

## Section 7 附录：参考资料清单
