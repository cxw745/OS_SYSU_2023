# 本科生实验报告

实验课程: 操作系统原理实验

任课教师: 刘宁

实验题目: **从实模式到保护模式**

专业名称: 计算机科学与技术

学生姓名: **陈雪玮**

学生学号: **21307387**

实验地点: 实验中心D501

实验时间: 2023.5.1

## Section 1 实验概述

* 学习C语言可变参数机制的实现方法。
  
  * 学习可变参数的原理，实现可变参数机制。
  
  * 实现可变参数后，实现一个printf函数。此后可以使用printf、gdb来debug。

* 实现内核线程。
  
  * 定义线程控制块的数据结构PCB，创建PCB。
  
  * 在PCB中放入线程执行需要的参数。
  
  * 实现基于时钟中断的RR调度算法。
  
  * 重点理解`asm_switch_thread`如何实现线程切换，体会操作系统实现并发执行的原理。

## Section 2 预备知识与实验环境

该节总结实验需要用到的基本知识，以及主机型号、代码编译工具、重要三方库的版本号信息等。

- 预备知识：x86汇编语言程序设计、Linux系统命令行工具

- 实验环境：
  
  - 虚拟机版本/处理器型号：Ubuntu18.04、i386
  
  - 代码编辑环境：Linux
  
  - 代码编译工具：makefile、gcc等
  
  - 重要三方库信息：

## Section 3 实验任务

- 实验任务1：printf的实现

- 实验任务2：线程的实现

- 实验任务3：时钟中断的处理

- 实验任务4：调度算法的实现

## Section 4 实验步骤与实验结果

### ------------------------- 实验任务1 -------------------------

- 任务要求：printf的实现

学习可变参数机制，然后实现printf，你可以在材料中的printf上进行改进，或者从头开始实现自己的printf函数。结果截图并说说你是怎么做的。

- 思路分析：
1. 学习可变参数机制。

2. 实现可变参数机制。

3. 利用可变参数机制实现printf函数。
- 实验步骤：
1. 学习可变参数机制。可变参数机制有以下要点：

> - 可变参数函数的参数列表分为两部分，前一部分是**固定参数**，后一部分是**可变参数**，用`...`表示。`printf`函数定义如下：
>   
>   ```c
>   int printf(const char* const _Format, ...);
>   ```
> 
> - 可变参数函数，参数列表中至少有一个固定参数。
> 
> - 可变参数列表必须放在函数参数列表的最后。
> 
> - 引用可变参数列表的参数，需要使用`<stdarg.h>`头文件中定义一个变量类型`va_list`，三个宏`va_start`​，`va_arg`​，`va_end`。用法如下：
>   
>   ```c
>   // 定义一个指向可变参数列表的指针。
>   va_list 
>   // 初始化可变参数列表指针 ap，使其指向可变参数列表的起始位置，
>   // 即函数的固定参数列表的最后一个参数 last_arg 的后面第一个参数。
>   va_start(va_list ap, last_arg) 
>   // 以类型 type 返回可变参数，并使 ap 指向下一个参数。
>   va_arg(va_list ap, type) 
>   // 清零 ap。
>   va_end(va_list ap)
>   ```
> 
> - C/C++函数调用规则——在函数调用前，函数的参数会被从右到左依次入栈。栈地址从高向低增长，因此函数的参数从左到右，地址依次增大。固定参数列表的最后一个参数的作用告诉我们可变参数列表的起始地址。
> 
> - 无论参数数量有多少，参数都被统一地按函数调用给出的顺序放到了栈上。可变参数函数不知道栈上的参数的具体含义，因此我们需要使用`va_arg​`来指定参数的类型后才能引用函数的可变参数。
> 
> - 可变参数列表的起始地址 = 固定参数列表的最后一个参数的地址 + 这个参数的大小。

2. 实现可变参数机制。主要是实现可变参数列表指针`va_list`和实现可变参数的三个宏`va_start`、`va_arg`、`va_end`。

实现`va_list`：

`va_list`​是指向可变参数列表的指针，占用一个字节，使用char类型实现，如下所示。

```c
typdef char * va_list;
```

实现`va_start`:

`va_start​`用于初始化一个指向可变参数列表起始地址的指针ap​，需要用到固定参数列表的最后一个变量v​，如下所示。

```c
#define _INTSIZEOF(n) ( (sizeof(n)+sizeof(int)-1) & ~(sizeof(int)-1) )
#define va_start(ap,v) ( ap = (va_list)&v + _INTSIZEOF(v) )
```

实现`va_arg`:

`va_arg`​的作用是返回ap​指向的，type​类型的变量，并同时使ap​指向下一个参数，如下所示。

```c
#define va_arg(ap, type) ( *(type *)((ap += _INTSIZEOF(type)) - _INTSIZEOF(type)))
```

实现`va_end`:

`va_end​`的作用是将ap​清零，如下所示。

```c
#define va_end(ap) ( ap = (va_list)0 )
```

3. 实现printf。printf的作用是格式化输出，并返回输出的字符个数，其定义如下。

```c
int printf(const char *const fmt, ...);
```

实现格式化输出字符串，即实现fmt的解析。printf首先找到fmt中的形如`%c,%d,%x,%s​`对应的参数，然后用这些参数具体的值来替换`%c,%d,%x,%s`​等，得到一个新的格式化输出字符串。由于字符串可能超过函数调用栈的大小，字符串会先被fmt逐字符解析，逐字符放入缓冲区中。放入一个字符后，如果缓冲区满了，则输出后清空缓冲区；否则不做处理。

能够解析以下参数。

| 符号  | 含义       |
| --- | -------- |
| %d  | 按十进制整数输出 |
| %c  | 输出一个字符   |
| %s  | 输出一个字符串  |
| %x  | 按16进制输出  |

实现能够输出字符串的函数，能正确处理`\n`换行符。换行的实现需要我们把光标放到下一行的起始位置，如果光标超过了屏幕的表示范围，则需要滚屏。

实现将字符加入到缓冲区的函数。

- 实验结果展示：通过执行前述代码，可得下图结果。

![](image/2023-05-02-21-31-10-image.png)

### ------------------------- 实验任务2 -------------------------

- 任务要求：线程的实现

自行设计PCB，可以添加更多的属性，如优先级等，然后根据你的PCB来实现线程，演示执行结果。

- 思路分析：

采用自顶向下的实现方式，先整体描述线程，然后逐步实现线程的管理、创建和调度。

- 实验步骤：

采用自顶向下的实现方式，先整体描述线程，然后逐步实现方法。

1. 描述线程

> - 创建一个枚举类型`ProgramStatus`描述线程五个状态。代码位于`include/thread.h`
> 
> ```c
> enum ProgramStatus
> {
>     CREATED,
>     RUNNING,
>     READY,
>     BLOCKED,
>     DEAD
> };
> ```
> 
> - 创建一个结构体`PCB`描述每一个线程的组成（内容）。代码位于`include/thread.h`
> 
> ```c
> struct PCB
> {
>     int *stack;                      // 栈指针，用于调度时保存esp
>     char name[MAX_PROGRAM_NAME + 1]; // 线程名
>     enum ProgramStatus status;       // 线程的状态
>     int priority;                    // 线程优先级
>     int pid;                         // 线程pid
>     int ticks;                       // 线程时间片总时间
>     int ticksPassedBy;               // 线程已执行时间
>     ListItem tagInGeneralList;       // 线程队列标识
>     ListItem tagInAllList;           // 线程队列标识
> };
> ```
> 
> - 声明一个程序管理类`ProgramManager`用于线程和进程的创建和管理。代码位于`include/program.h`
> 
> ```c
> #ifndef PROGRAM_H
> #define PROGRAM_H
> class ProgramManager
> {   
> };
> #endif
> ```
> 
> - 创建数据结构双向链表链表List，代码位于`include/list.h`。

2. 分配PCB

> - 分配PCB内存空间。一个PCB大小设置为4096Bytes，即4kB，一个页大小。向内存申请PCB，未用到页内存管理机制，所以需要在内存中预留若干个PCB的内存空间来存放和管理PCB。代码位于`include/program.cpp`。
> 
> ```c
> // PCB的大小，4KB。
> const int PCB_SIZE = 4096;     
> // 存放PCB的数组，预留了MAX_PROGRAM_AMOUNT个PCB的大小空间。
> char PCB_SET[PCB_SIZE * MAX_PROGRAM_AMOUNT]; 
> // PCB的分配状态，true表示已经分配，false表示未分配。
> bool PCB_SET_STATUS[MAX_PROGRAM_AMOUNT];   
> ```
> 
> - 实现管理PCB的方法。在`ProgramManager`​​中声明两个管理PCB所在的内存空间函数并实现，函数声明如下，实现代码位于`src/kernel/program.cpp​​`中。
> 
> ```c
> // 分配一个PCB:
> // 检查所有PCB中每一个PCB的状态，如果找到一个未被分配的PCB，
> // 返回这个PCB的起始地址。
> PCB *allocatePCB();
> // 归还一个PCB
> void releasePCB(PCB *program);
> ```

3. 创建线程

> - 在ProgramManager放入两个List成员，`allPrograms​`和`readyPrograms`​，分别放置所有状态的线程和进程的pid`PCB::tagInAllList`​和就绪队列中的线程和进程的pid`PCB::tagInGeneralList​`。
> 
> - 规定线程只能执行返回值为`void`，参数为`void*`的函数。`void *`​指向函数的参数。在`include/Program.h`​中将上面提到的这个函数定义为`ThreadFunction​`。
> 
> - 在`ProgramManager​`中声明一个用于创建线程的函数`executeThread​`，在`src/kernel/program.cpp`​中实现`executeThread`。
> 
> ```c
> // 创建一个线程并放入就绪队列
>     // function：线程执行的函数
>     // parameter：指向函数的参数的指针
>     // name：线程的名称
>     // priority：线程的优先级
>     // 成功，返回pid；失败，返回-1
>     int executeThread(ThreadFunction function, 
> \void *parameter, const char *name, int priority);
> ```

4. 调度线程，实现RR调度算法。

> - 在`ProgramManager​`中放入成员`running`​，表示当前在处理机上执行的线程的PCB。
> 
> - **线程调度**。实现函数`ProgramManager::schedule`，该函数实现**线程调度的功能**。主要步骤如下：
> 
> > 1. 关中断。
> > 
> > 2. 判断running线程状态。处于running态，放入就绪队列；处于dead态，释放PCB。
> > 
> > 3. 当前线程设为就绪态；将要换上的线程设为running态。
> > 
> > 4. 切换线程。
> > 
> > 5. 开中断。
> 
> - **RR线程调度算法**。修改之前的处理时钟中断函数，维护RR调度算法的计时。如下所示，代码保存在`src/kernel/interrupt.cpp`​中。**实现RR线程调度算法。
> 
> ```c
> extern "C" void c_time_interrupt_handler()
> {
>     PCB *cur = programManager.running        ;
>     // 当时钟中断到来时，我们对当前线程的`ticks`减1，
>     // 直到`ticks`等于0，然后执行线程调度
>     if (cur->ticks)
>     {
>         --cur->ticks;
>         ++cur->ticksPassedBy;
>     }
>     else
>     {
>         programManager.schedule();
>     }
> }
> ```
> 
> - **线程切换**。实现函数`asm_switch_thread`，该函数实现**线程切换的功能**。线程的所有信息都在线程栈中，切换线程就是切换线程栈，切换线程栈就是切换esp中的线程栈指针。代码放置在`src/utils/asm_utils.asm​​`中。

5. 在`setup.cpp`文件中创建线程并执行函数。

> - 执行第一个线程如下，C语言规定第一个线程不返回。因此最后使用`asm_halt()`。
> 
> ```c
> void first_thread(void *arg)
> {
>     // 第1个线程不可以返回
>     printf("pid %d name \"%s\": Hello World!\n", programManager.running->pid, programManager.running->name);
>     if (!programManager.running->pid)
>     {
>         //programManager.executeThread(second_thread, nullptr, "second thread", 1);
>         //programManager.executeThread(third_thread, nullptr, "third thread", 1);
>     }
>     asm_halt();
> }
> ```
> 
> - 执行的第二个线程如下，输出我的个人信息。
> 
> ```c
> void my_thread(void *arg){
>      printf("pid %d name \"%s\": 21307387_cxw\n", programManager.running->pid, programManager.running->name);
> }
> ```
> 
> - 创建线程并运行。
> 
> ```c
>     // 创建第一个线程
>     int pid = programManager.executeThread(first_thread, nullptr, "first thread", 1);
>     if (pid == -1)
>     {
>         printf("can not execute thread\n");
>         asm_halt();
>     }
>     // 创建我的线程
>          programManager.executeThread(my_thread, nullptr, "my thread", 1);
> 
>     // 调度第一个线程，将其强行放入
>     ListItem *item = programManager.readyPrograms.front();
>     PCB *firstThread = ListItem2PCB(item, tagInGeneralList);
>     firstThread->status = RUNNING;
>     programManager.readyPrograms.pop_front();
>     programManager.running = firstThread;
>     asm_switch_thread(0, firstThread);
> ```

- 实验结果展示：通过执行前述代码，可得下图结果。

![](image/2023-05-04-22-56-32-image.png)

### ------------------------- 实验任务3 -------------------------

- 任务要求：时钟中断的处理

操作系统的线程能够并发执行的秘密在于我们需要中断线程的执行，保存当前线程的状态，然后调度下一个线程上处理机，最后使被调度上处理机的线程从之前被中断点处恢复执行。现在，同学们可以亲手揭开这个秘密。
编写若干个线程函数，使用gdb跟踪c_time_interrupt_handler、 asm_switch_thread等函数，观察线程切换前后栈、寄存器、PC等变化，结合gdb、材料中“线程的调度”的内容来跟踪并说明下面两个过程。 

> - 一个新创建的线程是如何被调度然后开始执行的。
> 
> - 一个正在执行的线程是如何被中断然后被换下处理器的，以及换上处理机后又是如何从被中断点开始执行的。

通过上面这个练习，同学们应该能够进一步理解操作系统是如何实现线程的并发执行的。

- 思路分析：
1. 基于实验二的代码，进入`build`文件使用终端命令`make debug`进入debug界面。

2. 在gdb模式下，使用`b`在总函数入口`setup_kernel`、时钟中断函数`c_time_interrupt_handler`、线程切换函数`asm_switch_thread`设置中断。

3. 使用`c`、`n`、`s`执行函数，使用`p`打印变量内容、`i`查看寄存器内容。
- 实验步骤：

这里用来测试的是四个线程，第一个创建的`first_thread`，在运行时将创建`second_thread`和`third_thread`，第二个创建的是`my_thread`。

进入主函数。

![](image/2023-05-04-23-16-09-image.png)

进入创建线程函数，创建第一个线程，查看创建后的成员。

![](image/2023-05-04-23-18-37-image.png)

线程创建后，进入到线程切换函数。进入线程切换函数，将esp替换为下一个线程的栈地址，也就成功换上了线程。

![](image/2023-05-04-23-22-04-image.png)

![](image/2023-05-04-23-22-31-image.png)

时钟中断函数。每次调用都会减少该线程的一个时间片。若时间片还有，就继续执行；如果没了，就使用线程调度，换上新的线程。

![](image/2023-05-04-23-33-38-image.png)

![](image/2023-05-04-23-36-33-image.png)

- 实验结果展示：通过执行前述代码，可得下图结果。

![](image/2023-05-04-23-13-24-image.png)

### ------------------------- 实验任务4 -------------------------

- 任务要求：调度算法的实现

在材料中，我们已经学习了如何使用时间片轮转算法来实现线程调度。但线程调度算法不止一种，例如

> - 先来先服务。  
> 
> - 最短作业（进程）优先。  
> 
> - 响应比最高者优先算法。  
> 
> - 优先级调度算法。
> 
> - 多级反馈队列调度算法。

此外，我们的调度算法还可以是抢占式的。

现在，同学们需要将线程调度算法修改为上面提到的算法或者是同学们自己设计的算法。然后，同学们需要自行编写测试样例来呈现你的算法实现的正确性和基本逻辑。最后，将结果截图并说说你是怎么做的。

参考资料：[详解操作系统内核对线程的调度算法 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/97071815)

Tips：

> - 先来先服务最简单。  
> 
> - 有些调度算法的实现可能需要用到中断。

- 思路分析：

实现先到先来服务（FCFS）。

1. 为PCB增加一个剩余时间的变量，这里用ticks作为需要时间，通过修改priority可以修改需要时间。

2. 剩余时间为0，则换下一个进程进行；否则继续执行该进程知道剩余时间为0。
- 实验步骤：

修改时钟中断函数

```c
// 中断处理函数
extern "C" void c_time_interrupt_handler()
{
    //FSFC
    PCB *cur = programManager.running;

    // 调用一次中断，就减一次时间
    if (cur->ticks)
    {
        printf("pid %d stil need time %d\n",cur->pid,cur->ticks); 
        --cur->ticks;
    }
    else
    {
        // 所有进程都执行完了
    if(cur->status == ProgramStatus::DEAD)
        return ;
    printf("pid %d finished\n",cur->pid); 
        cur->status = ProgramStatus::DEAD;
        programManager.schedule();
    }
}
```

- 实验结果展示：通过执行前述代码，可得下图结果。

![](image/2023-05-04-23-59-54-image.png)

## Section 5 实验总结与心得体会

学习了C语言的可变参数机制，学习了创建线程的方法。通过这次实验，我对C语言有了更深入的理解，也对操作系统的线程有了更清晰的理解。

## Section 6 对实验的改进建议和意见

无

## Section 7 附录：参考资料清单
